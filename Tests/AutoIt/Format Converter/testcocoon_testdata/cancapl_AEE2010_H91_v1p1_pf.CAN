/*@@var:*/
/*--------------------------------------------------------------------------*/
// CAPL for DV Eu5 H91 with AEE2010
// updated 07/2009 J.Pfefferle ECP4
/*--------------------------------------------------------------------------*/
variables 
{

  /* Tastencodes fuer Cursortasten */
  CONST WORD _CursorUp    = 0x4800;
  CONST WORD _CursorDown  = 0x5000;
  CONST WORD _CurCtrlUp   = 0x8D00;
  CONST WORD _CurCtrlDown = 0x9100;
  CONST WORD _CursorRight = 0x4D00;
  CONST WORD _CursorLeft  = 0x4B00;

  /* Key codes for direct access to menus */
  CONST WORD _Ctrl_F1     = 0x5E00;
  CONST WORD _Ctrl_F10    = 0x6700;
  CONST WORD _Ctrl_F11    = 0x8900;
  CONST WORD _Ctrl_F12    = 0x8A00;


  /* Richtungen der Cursorbewegung */
  CONST WORD Up         = 1;            /* Richtung nach oben */
  CONST WORD Down       = 2;            /* Richtung nach unten */
  CONST WORD Ctrl_Up    = 3;            /* Richtung nach oben + Ctrl */
  CONST WORD Ctrl_Down  = 4;            /* Richtung nach unten + Ctrl */
  CONST WORD Left       = 5;            /* Richtung nach links */
  CONST WORD Right      = 6;            /* Richtung nach rechts */

  
  BYTE ElecInt_Active    = 0;           /* Flag to start sending of Elec_Int frames */
  BYTE ElecInt_NrFrames  = 10;          /* Nr of frames to transmit */

  BYTE FrameMonActv      = 1;           /* switch for activation of frame monitoring */
  
  /* Maximalwerte fuer Menue */
  CONST BYTE data_nr_max = 165;         /* max. Zahl der verstellbaren Daten */     
  CONST BYTE spalten_max = 13;          /* max. Zahl der Menues */                  
  CONST BYTE zeilen_max  = 18;          /* max. Zahl der Zeilen pro Menue */        
  CONST BYTE tx_msg_nr_max = 24;        /* Max. number of messages to be sent */          
  CONST BYTE rx_msg_nr_max = 14;        /* Max. number of messages to be received */          

  /* Timer deklarieren */
  Timer   timer_dynbva;  
  mstimer timer10ms;
  mstimer timer20ms;
  mstimer timer40ms;
  mstimer timer50ms;
  mstimer timer60ms;
  mstimer timer100ms;
//  mstimer timer250ms;                   /* Used for state machine traminator control */
  mstimer timer_mon500ms;               /* Used for period time measurement */
  mstimer timer1000ms;                        
  msTimer Absent_Timer;

  /* Messages to transmit */
  /*----------------------*/
  message CAN1.Dyn_V2_BVMP      DYN_V2_BVMP;          /* 349 */
  message CAN1.Dat_BSI          DAT_BSI;              /* 412 */
  message CAN1.Dat_CLIM         DAT_CLIM;             /* 50E */
  message CAN1.Dyn_CDS          DYN_CDS;              /* 34D */
  message CAN1.Dyn_ABR          DYN_ABR;              /* 38D */
  // message CAN1.CONTEXTE1        CONTXT1;           /* 7F2 */  /* only AEE2007 */
  message CAN1.Contexte1_5B2    CONTXT1;              /* 5B2 */  /* for  AEE2010 */
  message CAN1.Etat_Crash       CRASH;                /* 4C8 */
  message CAN1.Dyn2_FRE         DYN2_FRE;             /* 3CD */
  message CAN1.Dat_BSI1         DAT_BSI1;             /* 432 */
  // message CAN1.DAT4_BSI_AEE2007 DAT4_BSI;          /* 552 */  /* only AEE2007 */
  message CAN1.DAT4_BSI_AEE2010 DAT4_BSI;             /* 552 */  /* for  AEE2010 */
  message CAN1.FaultLog_Ack     FaultLog_Ack;         /* 772 */
  message CAN1.Dyn2_V2_BV       Dyn2_V2_BV;           /* 3C9 */
  message CAN1.Dat_V2_BV        Dat_V2_BV;            /* 489 */
  message CAN1.Elec_Int         Elec_Int;             /* 092 */
  message CAN1.Dyn_EasyMove     Dyn_EasyMove;         /* 3AD */
  message CAN1.Dat6_BSI         Dat6_BSI;             /* 592 */
  message CAN1.Dyn4_FRE         Dyn4_FRE;             /* 30D */
  message CAN1.Vroues_ABR       Vroues_ABR;           /* 44D */
  message CAN1.Dat_ABR          Dat_ABR;              /* 50D */
  message CAN1.Dyn_STT_BV       Dyn_STT_BV;           /* 329 */
  message CAN1.DAT_DIRA         DAT_DIRA;             /* 495 */
  message CAN1.Dat3_BSI         DAT3_BSI;             /* 4F2 */
  message CAN1.Dat7_BSI         DAT7_BSI;             /* 612 */
  
//  message CAN2.Tram_IdConfig    TRAM_CONFIG;
//  message CAN2.Tram_IdCde       TRAM_CDE;

  /* Messages to be received */
  /*-------------------------*/
  message CAN1.RQD_CMM          RQD_CMM;          /* 072 */        
  message CAN1.Vers_CMM         VERS_CMM;         /* 108 */
  message CAN1.Dyn_CMM          DYN_CMM;          /* 208 */
  message CAN1.Dyn2_CMM         DYN2_CMM;         /* 348 */
  message CAN1.Dyn_Veh          DYN_VEH;          /* 388 */
  message CAN1.Dat_CMM          DAT_CMM;          /* 488 */
  message CAN1.Supv_CMM         SUPV_CMM;         /* 788 */
  message CAN1.Dyn3_CMM         DYN3_CMM;         /* 468 */
  message CAN1.BSI_FaultLog     BSI_FaultLog;     /* 768 */
  message CAN1.EOBD_CMM         EOBD_CMM;         /* 608 */
  message CAN1.Dat2_CMM         Dat2_CMM;         /* 588 */
  message CAN1.DAT3_CMM         Dat3_CMM;         /* 1E8 */
  message CAN1.Dyn5_CMM         Dyn5_CMM;         /* 228 */
  message CAN1.Dyn_STT_CMM      Dyn_STT_CMM;      /* 3C8 */


  const byte RX_RQD_CMM      = 0;     /* 072 */
  const byte RX_VERS_CMM     = 1;     /* 108 */
  const byte RX_DYN_CMM      = 2;     /* 208 */
  const byte RX_DYN2_CMM     = 3;     /* 348 */
  const byte RX_DYN_VEH      = 4;     /* 388 */
  const byte RX_DAT_CMM      = 5;     /* 488 */
  const byte RX_SUPV_CMM     = 6;     /* 788 */
  const byte RX_DYN3_CMM     = 7;     /* 468 */
  const byte RX_BSI_FaultLog = 8;     /* 768 */
  const byte RX_EOBD_CMM     = 9;     /* 608 */
  const byte RX_Dat2_CMM     = 10;    /* 588 */
  const byte RX_Dat3_CMM     = 11;    /* 1E8 */
  const byte RX_Dyn5_CMM     = 12;    /* 228 */
  const byte RX_Dyn_STT_CMM  = 13;    /* 3C8 */ 


  /* Constants for message monitoring */
  const byte MON_ID     = 0;                      /* ID of message                   */
  const byte MON_DLC    = 1;                      /* Data Length Code of message     */
  const byte MON_PERIOD = 2;                      /* Period time of message          */
  const byte MON_COUNT  = 3;                      /* N° of messages to monitor       */
  char BSI_stkeypress   = 0   ;                   /* Is the BSI KEY press selected ? */
  CHAR rx_msg_name[rx_msg_nr_max][35];            /* Name of messages to be received */
  mstimer BSI_Ack ; 

  /* Parameter for each message to be monitored. */
  long PARAMETERS[rx_msg_nr_max][4] = {
    /*   ID, DLC, Period, N checks,    Message name    */
    {  0x72,   5,     10,       500},  /* RQD_CMM       */
    { 0x108,   8,      0,         0},  /* Vers_CMM      */
    { 0x208,   8,     10,       500},  /* Dyn_CMM       */
    { 0x348,   8,     20,       500},  /* Dyn2_CMM      */
    { 0x388,   7,     40,       500},  /* Dyn_Veh       */
    { 0x488,   8,    100,       500},  /* Dat_CMM       */
    { 0x788,   8,   1000,        50},  /* Supv_CMM      */
    { 0x468,   6,     40,       500},  /* Dny3_CMM      */
    { 0x768,   8,   1000,        50},  /* BSI_FaultLog  */ 
    { 0x608,   8,    100,       500},  /* EOBD_CMM      */  /* not periodic! */
    { 0x588,   8,    100,       500},  /* Dat2_CMM      */
    { 0x1E8,   3,   1000,        50},  /* Dat3_CMM      */
    { 0x228,   5,     10,       500},  /* Dyn5_CMM      */
    { 0x3C8,   2,     20,       500}   /* Dyn_STT_CMM   */
    };

  /* Variables for message monitoring */
  /* Array construction: mon_period[x][0] = number of message hits                  */
  /*                                  [1] = last time the message was received      */
  /*                                  [2] = sum of period time                      */
  /*                                  [3] = minimum period time                     */
  /*                                  [4] = maximum period time                     */
  /*                                  [5] = Marker request for displaying results   */
  const byte MON_HITS = 0;
  const byte MON_LAST = 1;
  const byte MON_SUM  = 2;
  const byte MON_MIN  = 3;
  const byte MON_MAX  = 4;
  const byte MON_DISP = 5;
  long mon_period[rx_msg_nr_max][6];

  /* Jeder Sende-Botschaft eine Nummer zuordnen */
  /* einfach durchnumerieren */
  CONST BYTE Dyn_V2_BVMP_Nr         = 0;
  CONST BYTE DAT_BSI_Nr             = 1;
  CONST BYTE DAT_CLIM_Nr            = 2;
  CONST BYTE DYN_CDS_Nr             = 3;    
  CONST BYTE DYN_ABR_Nr             = 4;
  CONST BYTE CONTXT1_Nr             = 5;
  CONST BYTE CRASH_Nr               = 6;
  CONST BYTE DYN2_FRE_Nr            = 7;
  CONST BYTE DAT_BSI1_Nr            = 8;
  CONST BYTE P__FaultLog_Ack_Nr     = 9;
  CONST BYTE Dyn2_V2_BV_Nr          = 10; 
  CONST BYTE Dat_BV_Nr              = 11; 
  CONST BYTE Elec_Int_Nr            = 12;   
  CONST BYTE Dyn_EasyMove_Nr        = 13;
  CONST BYTE Dat6_BSI_Nr            = 14;
  CONST BYTE Dyn4_FRE_Nr            = 15;
  CONST BYTE Vroues_ABR_Nr          = 16;    
  CONST BYTE Dat_ABR_Nr             = 17;
  CONST BYTE DAT4_BSI_Nr            = 18;
  CONST BYTE Dyn_STT_BV_Nr          = 19;
  CONST BYTE DAT_DIRA_Nr            = 20;
  CONST BYTE DAT3_BSI_Nr            = 21;
  CONST BYTE DAT7_BSI_Nr            = 22;
  CONST BYTE Dat_V2_BV_Nr           = 23;

  /* Jedem Sende-Datum eine Nummer zuordnen */
  /* einfach durchnumerieren */
  
  CONST BYTE Unused_Nr              =  0;
  CONST BYTE Reserved_Nr            =  1;
  CONST BYTE Absent_Timer_Nr        =  2;
  CONST BYTE Absent_Info_Nr         =  3;

  CONST BYTE ABSactive_Nr           =  4;
  CONST BYTE BVMPAactive_Nr         =  5;
  CONST BYTE CDSactive_Nr           =  6;
  CONST BYTE BSIactive_Nr           =  7;
  CONST BYTE Airbagactive_Nr        =  8;
  CONST BYTE P__Elec_Int_Cntrl_Word_Nr = 9;
  /* Signals for CAN Tool */
  
  /* Signals in message Dyn_V2_BVMP 349: */
  //CONST BYTE P087_Nr                = 10;   /* Clutch state */
  CONST BYTE PRes3_Nr               = 10;   /* spare parameter */
  CONST BYTE P057_Nr                = 11;   /* Torque intv */ 
  CONST BYTE P009_Nr                = 12;   /* shifting in progress FrmMng_stGearShift */
  CONST BYTE P085_Nr                = 13;   /* AC compressor inhibit FrmMng_stReqFrzACC */
  CONST BYTE P167_Nr                = 14;   /* state of engine speed control */
  CONST BYTE P287_Nr                = 15;   /* Gear engaged */
  CONST BYTE P283_Nr                = 16;   /* Gear requested */
  CONST BYTE Sim_counter_hang_349_Nr = 17;  /* counter hang simulation P230 */   
  CONST BYTE Sim_chksum_fault_349_Nr = 18;  /* checksum faulty simulation P340 */
  CONST BYTE P229_Nr                = 19;   /* BVMP request checksum */
  //CONST BYTE P055_Nr                = 23;   /* Torque limitation for gear box / Absolute torque request */
  CONST BYTE P166_Nr                = 20;   /* Desired engine speed */
  CONST BYTE P030_Nr                = 21;   /* Desired engine speed */
  CONST BYTE PRes4_Nr               = 22;   /* res */
  CONST BYTE P360_Nr                = 23;   /* Gearbox intv type */
  //CONST BYTE P361_Nr                = 27;   /* ABS intv active */ 
  CONST BYTE P362_Nr                = 24;   /* ABS intv active */ 
  CONST BYTE P333_Nr                = 25;   /* Gearshift phase */ 
  CONST BYTE P440_Nr                = 26;   /* P440_Com_bUCAPSWkUpReqRaw (Position levier de selection BV) */ 
  
      
  /* Signals in message Dat_BSI 412: */
  CONST BYTE P013_Nr                = 27;   /* main break switch */
  CONST BYTE P024_Nr                = 28;   /* not used yet */
  CONST BYTE P040_Nr                = 29;   /* Main break switch is defect.*/
  CONST BYTE P070_Nr                = 30;   /* not used yet */
  CONST BYTE P104_Nr                = 31;   /* FrmMng_stAOHt */
  CONST BYTE P068_Nr                = 32;   /* not used yet */
  CONST BYTE P086_Nr                = 33;   /* FrmMng_stFlMinRls Minimum fuel level is valid.*/
  CONST BYTE P012_Nr                = 34;   /* FrmMng_stFlMin Minimum fuel level is detected. */
  CONST BYTE P092_Nr                = 35;   /* not used yet */
  CONST BYTE P103_Nr                = 36;   /* Reverse gear status information */
  CONST BYTE P298_Nr                = 37;   /* Request to enable RTE Function */
  CONST BYTE P277_Nr                = 38;   /* Request to measure oil level */
  CONST BYTE P328_Nr                = 39;   /* Water pump status RTE V63*/ 
  CONST BYTE PRes1_Nr               = 40;   /* spare parameter */ 
  CONST BYTE PRes2_Nr               = 41;   /* spare parameter */ 
  
  /* Signals in message Etat_Crash 4C8 (also in menu of Dat_BSI 412): */
  CONST BYTE P223_Nr                = 42;   /* P223 Crash info about Airbag from the Body Car ECU */

  /* Signals in message Dat_BSI1 432: */  
  CONST BYTE P214_Nr                = 43;   /* Main wake-up (RCD ) */ 
  CONST BYTE P216_Nr                = 44;   /* Immobilizer anticipation with wake up  */
  CONST BYTE P249_Nr                = 45;   /* Engine stop request */
  CONST BYTE P251_Nr                = 46;   /* Secondary latched starting request */
  CONST BYTE P253_Nr                = 47;   /* Engine preparation request */
  CONST BYTE P267_Nr                = 48;   /* Refuel volume */
  CONST BYTE P274_Nr                = 49;   /* Refueling counter */
  CONST BYTE P276_Nr                = 50;   /* Starter oil measuring Wake-Up */
  CONST BYTE P350_Nr                = 51;   /* Post ventilation wake up */
  CONST BYTE P367_Nr                = 52;   /* JDD context */
  CONST BYTE P368_Nr                = 53;   /* SEV main state */
  CONST BYTE P369_Nr                = 54;   /* electricnetwork state */
  CONST BYTE P402_Nr                = 55;   /* start request */
  CONST BYTE P403_Nr                = 56;   /* status of start request */ 
  CONST BYTE P439_Nr                = 57;   /* UCAPS precharging/discharging wake up */

  /* Signals in message Dat4_BSI: */  
  /* for AEE2007: */
  // CONST BYTE P255_Nr                = 60;     /*  P255_Com_tiSec */ 
  // CONST BYTE P256_Nr                = 61;     /*  P256_Com_tiDay */
  // CONST BYTE P257_Nr                = 62;     /*  P257_Com_tiYr  */
  /* for AEE2010: */
  CONST BYTE P015_Nr                = 58;   /* P015_Com_lTotDst */ 
  CONST BYTE P325_Nr                = 59;   /* P325_Com_tiEngOff */
  CONST BYTE P326_Nr                = 60;   /* P326_Com_ctTmrRst */


  /* Signals in message Dat_CLIM 50E: */
  // CONST BYTE P050_Nr                = 63;   /* demand for air conditioning by driver AC-TH */
  CONST BYTE P164_Nr                = 61;   /* fan speed binary request by AC FrmMng_stPFltFan */
  CONST BYTE P046_Nr                = 62;   /* fan speed proportional request by AC FrmMng_rFanMinAC */
  CONST BYTE P169_Nr                = 63;   /* not used yet */
  CONST BYTE P144_Nr                = 64;   /* FrmMng_stPFltGlw Forcage_Encl_Bougies */
  CONST BYTE P189_Nr                = 65;   /* Offset for LIGOV*/
  CONST BYTE P208_Nr                = 66;   /* Idling request from BSI*/
  CONST BYTE P209_Nr                = 67;   /* AC when Clutch is pressed*/
  CONST BYTE P210_Nr                = 68;   /* AC power*/
  CONST BYTE P417_Nr                = 69;   /* STT Driver presence */
  CONST BYTE P432_Nr                = 70;   /* STT Engine restart requested by sub system HAB */
  CONST BYTE P433_Nr                = 71;   /* STT Engine stop authorization by sub system HAB */  
  
  /* Cruise control signals */
  CONST BYTE P219_Nr                = 72;   /* Vehicle speed set point */    
  CONST BYTE P220_Nr                = 73;   /* Speed set point type  */
  CONST BYTE P221_Nr                = 74;   /* Type of Prp Ctl Request  */  
  CONST BYTE P222_Nr                = 75;   /* Speed limitation request  */
  CONST BYTE P231_tx_Zero_Cnt_Nr    = 76;   /* Send zero as counter value */ 
  CONST BYTE P231_Typ_Cnt_Nr        = 77;   /* Typ Count selection
                                               0 - Old Implementation
                         1 - Send '0' times the above count then 1,3,5..
                         2 - send 0,1,3..15,1,3...
                         3 - send 0,2,4..14,2,4 */ 
  CONST BYTE P231_Nr                = 78;   /* CrcCtl process counter */ 
  CONST BYTE P231_CntrHang_Nr       = 79;   /* CrCtl process counter hang */
  CONST BYTE P232_Nr                = 80;   /* Checksum */
  CONST BYTE P232_InVld_Nr          = 81;   /* Checksum calculation hang */ 
  CONST BYTE CrCtl_Select_Nr        = 82;   /* Option in tabale of CrCtl : None */
 
  /* Signals in message Dyn_ABR 38D: */
  CONST BYTE P010_Nr                = 83;   /* ABS velocity     */
  CONST BYTE P052_Nr                = 84;   /* ABS acceleration */
  CONST BYTE P688_Nr                = 85;   /* Hill assist stop authorization for STT */

  /* Signals in message CONTXT1 7F2/5B2: */
  /* AEE2007 7F2: */
  // CONST BYTE P__Diagnostic_On_Can_Nr= 91;    
  // CONST BYTE P__Local_ID_Nr         = 92;          
  // CONST BYTE P100_Nr                = 94;   /* FrmMng_stAddPmpDef Status of additive */
  // CONST BYTE Etat_EOBD              = 95;   /*  State of EOBD info from BSI */
  // CONST BYTE P146_Nr                = 96;   /* Environment air temperature */
  // CONST BYTE P015_Nr                = 97;   /* BSI odometer (distance on dash-board) */
  
  /* AEE2010 5B2: */
  CONST BYTE P100_Nr                = 86;   /* FrmMng_stAddPmpDef Status of additive */
  CONST BYTE P146_Nr                = 87;   /* Environment air temperature */
  CONST BYTE P__Com_stEOBD_Nr       = 88;   /* State of EOBD info from BSI */

  
  /* Signals in message Dyn_CDS 34D: */
  CONST BYTE P047_Nr                = 89;   /* ESP torque request status */
  CONST BYTE P088_Nr                = 90;   /* ESP cut off of injections is forbidden. */
  CONST BYTE P147_Nr                = 91;   /* ESP TCS (ASR) in regulation */
  CONST BYTE P043_Nr                = 92;   /* ESP TCS (ASR) static torque request */
  CONST BYTE P044_Nr                = 93;   /* ESP TCS (ASR) dynamic torque request */
  CONST BYTE P045_Nr                = 94;   /* ESP DCS (MSR) torque request */
  CONST BYTE P157_Nr                = 95;   /* ESP Counter */
  CONST BYTE CounterFault_Nr        = 96;   /* ESP simulation counter is hanging */
  CONST BYTE TCSStatFault_Nr        = 97;   /* ESP simulation of invalid TCS static torque */
  CONST BYTE TCSDynFault_Nr         = 98;   /* ESP simulation of invalid TCS dynamic torque */
  CONST BYTE DCSFault_Nr            = 99;   /* ESP simulation of invalid DCS torque */
  CONST BYTE P353_Nr                = 100;  /* ESP intervantion active */
  CONST BYTE P352_Nr                = 101;  /* TCS intv active  */

  /* Signals in message Dyn2_FRE 3CD (also in the menu of Dyn_ABR 38D): */
  CONST BYTE P225_Nr                = 102;
  CONST BYTE P224_Nr                = 103; 
  CONST BYTE P226_Nr                = 104;
  CONST BYTE P319_Nr                = 105;
  CONST BYTE P515_Nr                = 106;  /* P515_Com_pStSpMstCyl, TMC pressure */

  
  /* Signals in message Dat_V2_BV 489 */ 
  CONST BYTE P218_Nr                = 107;  /* Driving type/ Sportive index */
  CONST BYTE P282_Nr                = 108;  /* BVA error states  */
  CONST BYTE P285_Nr                = 109;  /* Start Inhibition request from AM6  */
  CONST BYTE P029_Nr                = 110;  /* Gearbox program */
  CONST BYTE P374_Nr                = 111;  /* Readiness flag not set for OBD errors on Gbx */
  CONST BYTE P375_Nr                = 112;  /* MIL request */
  CONST BYTE P376_Nr                = 113;  /* Clear MIL KM counter */  

/* Signals in message Dyn2_BV 3C9 */
  // CONST BYTE P363_Nr                = 121;
  // CONST BYTE P364_Nr                = 124;

/* Signals in message Dyn2_V2_BV 3C9 */
  CONST BYTE P291_Nr                = 114;    /* P291_Com_trqMaxConv */
  CONST BYTE P293_Nr                = 115;    /* P293_Com_stGbxEngShOff */
  CONST BYTE Sim_counter_hang_3C9_Nr = 116;
  CONST BYTE Sim_chksum_fault_3C9_Nr = 117;
  CONST BYTE P__Rapport_cible_Nr     = 118;
  
  /* Signals in message Dyn_EasyMove 3AD: */ 
  CONST BYTE P299_Nr                = 119;
  CONST BYTE P337_Nr                = 120;

  /* Signals in message Dat6_BSI 592 */ 
  CONST BYTE P272_Nr                = 121;   /* Percentage of battery charge */ 
  CONST BYTE P273_Nr                = 122;   /* Battery temperature */ 
  CONST BYTE P349_Nr                = 123;   /* Alternator control Type */
  CONST BYTE P418_Nr                = 124;   /* BECB battery voltage */
  CONST BYTE P419_Nr                = 125;   /* STT state change request */
  CONST BYTE P420_Nr                = 126;   /* Battery current's measurement caliber */
  CONST BYTE P421_Nr                = 127;   /* Battery current */

  /* Signals in message Dyn4_FRE 30D    */ 
  CONST BYTE P263_Nr                = 128;   /* Front right wheel speed */ 
  CONST BYTE P264_Nr                = 129;   /* Front left wheel speed  */ 

  /* Signals in message Vroues_ABR 44D */ 
  CONST BYTE P330_Nr                = 130;   /* Percentage of battery charge */ 
  CONST BYTE P331_Nr                = 131;   /* Battery temperature */ 
  CONST BYTE P354_Nr                = 132;   /* Alternator control Type */

  /* Signals in message Dat_ABR 50D */ 
  CONST BYTE P351_Nr                = 133;   /* ABS intv active */ 
  CONST BYTE P415_Nr                = 134;   /* P415_Com_stABSSTTReqRaw */
 /* End Signals for CAN Tool */


  /* Signals in message Dyn5_CMM 228: */ 
  CONST BYTE P320_Nr                = 135;    /* P320_EasyMvTrqInfo */
  CONST BYTE P321_Nr                = 136;    /* P321_StatusOfEasyMvTrq */
  CONST BYTE P334_Nr                = 137;    /* P334_ACCPed_Position */
  CONST BYTE P335_Nr                = 138;    /* P335_Com_ctDyn5CMMCntr */
  CONST BYTE P336_Nr                = 139;    /* P336_Com_xDyn5CMMChkSum */
  CONST BYTE P388_Nr                = 140;    /* P388_Com_rClthPedPos */
  CONST BYTE P410_Nr                = 141;    /* P410_Com_stEngTrqStSp */
  CONST BYTE P411_Nr                = 142;    /* P411_Com_stTrqAvlStSp */

  /* Signals in message Dyn_STT_BV 329: */ 
  CONST BYTE P441_Nr                = 143;    /* P441_Com_bGbxAuthRstrtRaw */
  CONST BYTE P442_Nr                = 144;    /* P442_Com_bGbxAuthStopRaw  */
  CONST BYTE P443_Nr                = 145;    /* P443_Com_bGbxRstrtReq     */
  CONST BYTE P444_Nr                = 146;    /* P444_Com_bGbxSysFaultRaw  */
  CONST BYTE Sim_counter_hang_329_Nr = 147;   /* P230 counter hang simulation */
  CONST BYTE Sim_chksum_fault_329_Nr = 148;   /* P340 checksum faulty simulation */
  
  /* Signals in message Dyn_STT_CMM 3C8: */ 
  CONST BYTE P412_Nr                = 149;    /* P412_Com_stDeadPnt, Neutral position */
  CONST BYTE P428_Nr                = 150;    /* P428_Com_stCDTReq, request opening/closing CDT */
  
  /* Signals in message DAT_DIRA 495: */ 
  CONST BYTE P447_Nr                = 151;    /* P447_Com_bStrgWhlEngRstrtReqRaw */
  CONST BYTE P448_Nr                = 152;    /* P448_Com_bStrgWhlEngStopReqRaw  */
  
  
  /* Signals in message DAT3_BSI 4F2: */ 
  CONST BYTE P429_Nr                = 153;    /* P429_Com_stSOCInfoInvldRaw */
  CONST BYTE P435_Nr                = 154;    /* P435_Com_stUCAPRechCrntRaw  */
  CONST BYTE P434_Nr                = 155;    /* P434_Com_rBattChHiRes  */
  CONST BYTE P438_Nr                = 156;    /* P438_Com_uBattIntRstnRaw  */
  CONST BYTE P437_Nr                = 157;    /* P437_Com_uBattOpnCir  */
  CONST BYTE P493_Nr                = 158;    /* P493_Com_stPrioVoltMin  */
  CONST BYTE P490_Nr                = 159;    /* P490_Com_uVoltCtlProdMin  */
  CONST BYTE P494_Nr                = 160;    /* P494_Com_stPrioVoltMax  */
  CONST BYTE P491_Nr                = 161;    /* P491_Com_uVoltCtlProdMax  */
  CONST BYTE P492_Nr                = 162;    /* P492_Com_uVarProdMax  */
  
  /* Signals in message DAT7_BSI 612: */ 
  CONST BYTE P409_Nr                = 163;    /* P409_Com_stRly3DiagRaw */
  
  
/*================================================================================================*/


  
  CHAR header[45]    = "********************************************";
  CHAR unterstr[45]  = "--------------------------------------------";
  CHAR leerzeile[35] = "                                  ";
  CHAR revision[35]  = " PSA Mux V2.6 ";

  int data_sel = 1;
  int spalte_sel = 0;                                          /* selektierte Spalte */
  int zeile_sel[spalten_max];                                  /* selektierte Zeile pro Spalte */
  int letzte_zeile[spalten_max];                               /* letzte benutzte Zeile einer Spalte */
    
  BYTE sendestopp = 0;                                         /* unterbreche Senden von Daten */

/*------------------------------------------------------------------------------------------------*/

  /* table with menu descriptions: */
  /* ----------------------------- */
  CHAR menu_desc[spalten_max][75] =
  {
    "Transmission control and active nodes",                            /* menu 0 */
    "Dyn_V2_BVMP (349)",                                                /* menu 1 */
    "Dat_BSI (412), Etat_Crash (4C8)",                                  /* menu 2 */
    "Dat_BSI1 (432), Dat4_BSI (552)",                                   /* menu 3 */
    "Dat3_BSI (4F2), DAT7_BSI (612)",                                   /* menu 4 */
    "Dat_CLIM (50E)",                                                   /* menu 5 */
    "Cruise control signals Dat_CLIM (50E)",                            /* menu 6 */
    "Dyn_CDS ID (34D)",                                                 /* menu 7 */
    "Dyn_ABR (38D), Dyn2_FRE (3CD)",                                    /* menu 8 */
    "CONTEXTE1 ID (7F2/5B2)",                                           /* menu 9 */
    "Dat_V2_BV (489), Dyn2_V2_BV (3C9), Dyn_EasyMove (3AD)",            /* menu 10 */
    "Dat6_BSI (592), Dyn4_FRE (30D), Vroues_ABR (44D), Dat_ABR (50D)",  /* menu 11 */
    "Dyn_STT_BV (329), DAT_DIRA (495)"                                  /* menu 12 */
  };
  
/*------------------------------------------------------------------------------------------------*/
  
  /* Tabelle, die jedem Menue (Spalte) ein verstellbares Datum (Zeile) zuordnet */
  /* -------------------------------------------------------------------------- */
  BYTE data_tab[spalten_max][zeilen_max] = 
  {  
    /* Menue 0 (Transmission control and active nodes) */
    { 
      Absent_Timer_Nr, 
      Absent_Info_Nr,
      ABSactive_Nr,
      BVMPAactive_Nr,
      CDSactive_Nr,
      BSIactive_Nr,
      Airbagactive_Nr,
      P__Elec_Int_Cntrl_Word_Nr,
      0,0,0,0,0,0,0,0,0,0
    },
     
    /* Menue 1: message Dyn_V2_BVMP (349) */
    { 
      //P087_Nr,            /* Clutch state */
      P009_Nr,            /* shifting in progress FrmMng_stGearShift */
      P057_Nr,            /* Torque intv */
      P085_Nr,            /* AC compressor inhibit FrmMng_stReqFrzACC */
      P167_Nr,            /* state of engine speed control */
      P287_Nr,            /* Gear engaged */
      P283_Nr,            /* target gear */
      Sim_counter_hang_349_Nr, /* Counter hang simulation P230 */
      Sim_chksum_fault_349_Nr, /* Checksum fault simulation P340 */
      //P055_Nr,            /* Torque limitation for gear box / Absolute torque request */
      P166_Nr,            /* Desired engine speed */
      P030_Nr,            /* drive train status */
      P333_Nr,            /* Gearshift phase */ 
      P360_Nr,            /* P360 Gbx_stIntvTyp, Gearbox intv type */
      P362_Nr,            /* ABS intv active */
      P440_Nr,            /* P440_Com_bUCAPSWkUpReqRaw */
      0,0,0,0
    },  
      
    /* Menue 2: message Dat_BSI (412), Etat_Crash (4C8) */
    { 
      /* 412 */
      P013_Nr,            /* main break switch */
      P040_Nr,            /* Main break switch is defect.*/
      P104_Nr,            /* FrmMng_stAOHt */
      P086_Nr,            /* FrmMng_stFlMinRls Minimum fuel level is valid.*/
      P012_Nr,            /* FrmMng_stFlMin Minimum fuel level is detected. */
      P298_Nr,            /* Request to enable RTE function */
      P103_Nr,            /* Reverse gear status */
      P277_Nr,            /* Request oil level measurement */
      P328_Nr,            /* Water pump status RTE V63 */
      /* 4C8 */
      P223_Nr,            /* Crash info about Airbag from the Body Car ECU */
      0,0,0,0,0,0,0,0
    },

    /* Menu 3: message Dat_BSI1 (432), Dat4_BSI (552)  */
    {
      /* 432 */
      P214_Nr,            /*  Main wake-up (RCD ) */ 
      P216_Nr,            /*  Immobilizer anticipation with wake up  */
      P249_Nr,            /*  Engine stop request */
      //P251_Nr,            /*  Secondary latched starting request */   /* AEE2007 only*/
      P253_Nr,            /*  Engine preparation request */
      P267_Nr,            /*  Refuel volume */
      P274_Nr,            /*  Refueling counter */
      P276_Nr,            /*  Starter oil measuring Wake-Up */
      // P255_Nr,            /* Time in seconds since engine stop */    /* AEE2007 only*/
      // P256_Nr,            /* Time in days since engine stop  */
      // P257_Nr,            /* Time in years since engine stop  */
      P350_Nr,            /* Post ventilation wake up */
      P367_Nr,            /* JDD context */
      P368_Nr,            /* SEV main state */
      P369_Nr,            /* electricnetwork state */
      P402_Nr,            /* start request */
      P403_Nr,            /* status of start request */ 
      P439_Nr,            /* UCAPS precharging/discharging wake up */
      /* 552 */
      P015_Nr,            /* P015_Com_lTotDst */ 
      P325_Nr,            /* P325_Com_tiEngOff */
      P326_Nr,            /* P326_Com_ctTmrRst */
      0
    },

    /* Menu 4: message Dat3_BSI (4F2), DAT7_BSI (612)  */
    {
      /* 4F2 */
      P429_Nr,            /* P429_Com_stSOCInfoInvldRaw */
      P435_Nr,            /* P435_Com_stUCAPRechCrntRaw  */
      P434_Nr,            /* P434_Com_rBattChHiRes  */
      P438_Nr,            /* P438_Com_uBattIntRstnRaw  */
      P437_Nr,            /* P437_Com_uBattOpnCir  */
      P493_Nr,            /* P493_Com_stPrioVoltMin  */
      P490_Nr,            /* P490_Com_uVoltCtlProdMin  */
      P494_Nr,            /* P494_Com_stPrioVoltMax  */
      P491_Nr,            /* P491_Com_uVoltCtlProdMax  */
      P492_Nr,            /* P492_Com_uVarProdMax  */
      /* 612 */
      P409_Nr,            /* P409_Com_stRly3DiagRaw */
      0,0,0,0,0,0,0
    },

    /* Menue 5: message Dat_CLIM (50E) */
    { 
      // P050_Nr,            /* demand for air conditioning by driver AC-TH */
      P164_Nr,            /* fan speed binary request by AC FrmMng_stPFltFan */
      P046_Nr,            /* fan speed proportional request by AC FrmMng_rFanMinAC */
      P144_Nr,            /* FrmMng_stPFltGlw Forcage_Encl_Bougies */
      P189_Nr,
      P208_Nr,
      P209_Nr,
      P210_Nr,
      P417_Nr,            /* STT Driver presence */
      P432_Nr,            /* STT Engine restart requested by sub system HAB */
      P433_Nr,            /* STT Engine stop authorization by sub system HAB */  
      0,0,0,0,0,0,0,0
    },

    /* Menue 6:  Cruise control signals  */
    {
      P219_Nr,
      P220_Nr,
      P221_Nr,
      P222_Nr,
      P231_tx_Zero_Cnt_Nr,
      P231_Typ_Cnt_Nr,
      P231_CntrHang_Nr,
      P232_InVld_Nr,
      CrCtl_Select_Nr,       /*  Option in tabale of CrCtl */
      0,0,0,0,0,0,0,0,0
        
    },

    /* Menue 7: message Dyn_CDS ID (34D) */
    { 
      P047_Nr,            /* ESP torque request status */
      P147_Nr,            /* ESP TCS (ASR) in regulation */
      CounterFault_Nr,    /* ESP simulation counter is hanging */
      TCSStatFault_Nr,    /* ESP simulation of invalid TCS static torque */
      TCSDynFault_Nr,     /* ESP simulation of invalid TCS dynamic torque */
      DCSFault_Nr,        /* ESP simulation of invalid DCS torque */
      P043_Nr,            /* ESP TCS (ASR) static torque request */
      P044_Nr,            /* ESP TCS (ASR) dynamic torque request */
      P045_Nr,            /* ESP DCS (MSR) torque request */
      0,0,0,0,0,0,0,0,0
    },

    /* Menue 8: message Dyn_ABR (38D), Dyn2_FRE (3CD) */
    { 
      /* 38D */
      P010_Nr,            /* ABS velocity     */
      P052_Nr,            /* ABS acceleration */
      P688_Nr,            /* Hill assist stop authorization for STT */
      /* 3CD */
      P225_Nr,            /* Brake information*/
      P224_Nr,            /* Brake information*/
      P226_Nr,            /* Braking in action */
      P319_Nr,            /* Clutch pedal position */
      P515_Nr,            /* P515_Com_pStSpMstCyl, TMC pressure */
      0,0,0,0,0,0,0,0,0,0

    },

    /* Menue 9: message CONTEXTE1 ID (7F2/5B2) */
    { 
      // P__Diagnostic_On_Can_Nr,            
      // AEE2007 P__Local_ID_Nr,                     
      // AEE2007 P015_Nr,            /* BSI odometer (distance on dash-board) */
      P100_Nr,            /* FrmMng_stAddPmpDef Status of additive */
      P146_Nr,            /* Environment air temperature */
      P__Com_stEOBD_Nr,   /*  State of EOBD info from BSI */
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },

    /* Menue 10: message Dat_V2_BV (489), Dyn2_V2_BV (3C9), Dyn_EasyMove (3AD) */
    { 
      /* 489 */
      P218_Nr,            /* Driving type/ Sportive index */
      P282_Nr,            /* BVA error states  */
      P285_Nr,            /* Start Inhibition request from AM6  */
      P029_Nr,            /* Gearbox program */
      P374_Nr,            /* Readiness flag not set for OBD errors on Gbx */
      P375_Nr,            /* MIL request */
      P376_Nr,            /* Clear MIL KM counter */  
      /* 0x3C9 */ 
      P291_Nr,            /* P291_Com_trqMaxConv */
      P293_Nr,            /* P293_Com_stGbxEngShOff, Engine off request from BV */
      // P363_Nr,           /* Relative torque of the convertor */  /* from Dyn2_BV */
      // P364_Nr,           /* Extended Gearshaft speed */
      Sim_counter_hang_3C9_Nr, /* To simulate process counter error */
      Sim_chksum_fault_3C9_Nr, /* Checksum fault simulation P340 */
      /* 0x3AD */ 
      P299_Nr,            /* Status of cruise control inhibit */
      P337_Nr,            /* Parking brake Status */ 
      0,0,0,0,0
    },
    

    /* Menue 11: message Dat6_BSI (592), Dyn4_FRE (30D), Vroues_ABR (44D), Dat_ABR (50D) */
    {
      /* 592 */
      P272_Nr,             /* Battery Charge Percentage  */ 
      P273_Nr,             /* Battery temperature        */
      P349_Nr,             /* Alternator control type    */ 
      P418_Nr,             /* BECB battery voltage */
      P419_Nr,             /* STT state change request */
      P420_Nr,             /* Battery current's measurement caliber */
      P421_Nr,             /* Battery current */
      /* 30D */
      P263_Nr,             /* Front left wheel velocity  */ 
      P264_Nr,             /* Front right wheel velocity */ 
      /* 44D */
      P330_Nr,             /* Rear left wheel velocity   */ 
      P331_Nr,             /* Rear right wheel velocity  */ 
      P354_Nr,             /* Average wheel speed        */ 
      /* 50D */
      P351_Nr,             /* ABS intervention active     */
      P415_Nr,             /* brake function for STT need */
      0,0,0,0
    },
    
    /* Menue 12: message Dyn_STT_BV (329), DAT_DIRA (495) */
    {
      /* 329 */
      P441_Nr,             /*  P441_Com_bGbxAuthRstrtRaw*/
      P442_Nr,             /*  P442_Com_bGbxAuthStopRaw   */
      P443_Nr,             /*  P443_Com_bGbxRstrtReq */
      P444_Nr,             /*  P444_Com_bGbxSysFaultRaw*/
      Sim_counter_hang_329_Nr, /* counter hang simulation P230 */
      Sim_chksum_fault_329_Nr, /* checksum fault simulation P340 */
      /* 495 */
      P447_Nr,             /* P447_Com_bStrgWhlEngRstrtReqRaw */
      P448_Nr,             /* P448_Com_bStrgWhlEngStopReqRaw  */
      0,0,0,0,0,0,0,0,0,0
    }
    
  };
  /* -------------------------------------------------------------------------- */

  /* Daten-Variablen der CAN-Messages wurden auf LONG geändert, da 16-Bit-unsigned-Variable     */
  /* (Quant_Tot_Additiv) eingeführt wurde.                                                      */

  CHAR data_name[data_nr_max][35];        /* Name der Daten */
  LONG data[data_nr_max];                 /* Wert der Daten */                              
  LONG min_wert[data_nr_max];             /* Min-Wert der Daten */                          
  LONG max_wert[data_nr_max];             /* Max-Wert der Daten */                          

  CHAR tx_msg_name[tx_msg_nr_max][35];    /* Name of messages to be sent */
  WORD lost_msg_cnt[tx_msg_nr_max];       /* Zaehler, wie oft Message nicht gesendet */

  MESSAGE CAN1.* SendMsg[tx_msg_nr_max];  /* Message-Feld */

  BYTE proc_counter_349;                  /* BVMP message counter */   
  BYTE proc_counter_3C9;                  /* BV  message counter */   
  BYTE proc_counter_329;                  /* STT message counter */   
  BYTE ChkSum_349;                        /* BVMP data chk sum */   
  BYTE ChkSum_3C9;                        /* BV data chk sum */   
  BYTE ChkSum_329;                        /* STT data chk sum */   
  BYTE ChkSum_349_Tmp;                    /* Temporary variable for BVMP chk sum */   
  BYTE ChkSum_3C9_Tmp;                    /* Temporary variable for BV chk sum */   
  BYTE ChkSum_329_Tmp;                    /* Temporary variable for STT chk sum */   
  BYTE ChkSum_CrcCtl;                     /* Temp val for checksum */
  BYTE DataCounter_CrCtl;                 /* CrcCtl process counter  */ 
  BYTE P232_ChkSum ;                      /* Final checksum of P232 */
  BYTE cnt_zero = 0 ;                     /* Count the '0' tx */
  BYTE fst_tx2 = 0  ;                     /* Flag for 1st TX */
  BYTE fst_tx3 = 0 ;                      /* Flag for 1st TX */
  BYTE Old_TypCnt = 0 ;                   /* old vale of cnt type cnt */
  
  BYTE data_Counter;                      /* ESP message counter */ 
  BYTE data_Mode_Reg_CdS;                 /* ESP-Betriebsart */
  LONG data_Cons_Stat_TCS;                /* ESP stat. TCS (ASR) torque */
  LONG data_Cons_Dyn_TCS;                 /* ESP dyn.  TCS (ASR) torque */
  LONG data_Cons_DCS;                     /* ESP DCS (MSR) torque */
  BYTE count_CONTXT1;                     /* CONTEXTE1-Botschftszaehler */

  BYTE Timer_DynBVA_Flag;                 /* For varying the 0x349 time period */
  BYTE Timer_DynBVA_Var;                  /* For varying the 0x349 time period */  
  /*                                                                                            */
  /* Hardware configuration for Traminator use:                                                 */
  /*                                                                                            */
  /* Configuration switches:                                                                    */
  /*                                                                                            */
  /* +-----+-----+-----+-----+-----+-----+-----+-----+                                          */
  /* | SW1 | SW2 | SW3 | SW4 | SW5 | SW6 | SW7 | SW8 |                                          */
  /* +-----+-----+-----+-----+-----+-----+-----+-----+                                          */
  /* |  0  |  0  |  0  |  0  |  0  |  0  |  1  |  0  |                                          */
  /* +-----+-----+-----+-----+-----+-----+-----+-----+                                          */
  /*    |     |     |     |     |     |     |     |                                             */
  /*    |     |     |     |     |     +-----+-----+------- Baud rate to ECU 125 kbits/s         */
  /*    |     |     |     |     +------------------------- Sloped transition                    */
  /*    +-----+-----+-----+------------------------------- Operating mode: remote               */
  /*                                                                                            */
  /*                                                                        I_S_BRKRED (305)    */
  /*                                                                                |           */
  /*                                                              +--------------+  |           */
  /*     +---------------------------------------+    +-----------| Oszilloscope |--+           */
  /*     | Channel 2 (500kBit/s)     CAN-CONTROL |    | TRIG-OUT  +--------------+  |           */
  /* +-----------+                       +---------------+                          |           */
  /* |           |                       |               |                          |           */
  /* | CANalyzer |                       |  TRAMINATOR   |                          |           */
  /* |           |                       |   CAN /ESL    |                          |           */
  /* +-----------+                       +---------------+                          |           */
  /*     | Channel 1 (250kBit/s)             CAN |    | CAN-ECU   +-------------------+         */
  /*     +---------------------------------------+    +-----------| ECU EDC16C3 - PSA |         */
  /*                                                              +-------------------+         */
  /*                                                                                            */

  /* Constants for Traminator control */
  CONST long TRAM_ID_CDE    =0x48A;       /* Identifier used by Traminator to receive commands  */
  CONST long TRAM_ID_STATUS =0x4A5;       /* Identifier used by Traminator to send replies      */

  /* Message Tram_IdConfig, identifier 0x000 */
  CONST BYTE TRAM_GETCONFIGID   = 0x00;   /* Identifier configuration reading command           */
  CONST BYTE TRAM_CONFIGID      = 0x01;   /* Identifier configuration writing command           */
  CONST BYTE TRAM_GETCONFIGTRAM = 0x02;   /* Traminator script configuration reading command    */
  CONST BYTE TRAM_CONFIGTRAM    = 0x03;   /* Traminator script configuration writing command    */
  CONST BYTE TRAM_GETVERSION    = 0x06;   /* Version reading command                            */

  /* Identifiers ID_Cde and ID_Status */
  CONST BYTE TRAM_BUSTOGROUND   = 0x02;   /* Grounding of CANH and CANL                         */
  CONST BYTE TRAM_BUSTONORMAL   = 0x03;   /* Cancel the grounding of CANH and CANL              */
  CONST BYTE TRAM_BUSISOL       = 0x04;   /* Isolation of the module to test. Opening of CANH   */
                                          /* and CANL lines                                     */
  CONST BYTE TRAM_BUSCONNECT    = 0x05;   /* Set the connection to the module to test.          */
                                          /* CANH and CANL lines are closure.                   */
  CONST BYTE TRAM_CHANGEMODE    = 0x0E;   /* Mode change, e.g. script, ESL or remote mode.      */
  CONST WORD TRAM_MAXDLYREPLY   = 0x0004; /* Maximum of response time on Traminator reading     */
                                          /* request. 4 * 250 ms = 1 s                          */

  /* Variables for Traminator control */
  long ID_Cde;                            /* Identifier read from Traminator (ID command)       */
  long ID_Status;                         /* Identifier read from Traminator (ID replies)       */
  BYTE ScriptNo;                          /* Script: Traminator scenario number                 */
                                          /* 1 = ERR_FRAME destruction    (standard type)       */
                                          /* 2 = ISOL_ACK_9 destruction   (standard type)       */
                                          /* 3 = ISOL_ACK_2 destruction   (standard type)       */
                                          /* 4 = SCRAMBLE_ACK destruction (standard type)       */
                                          /*                                                    */
  WORD ScriptMaxCount           = 0x0000; /* After MaxCount is expired get back to remote mode  */
  long ScriptID;                          /* Script: ID of message to disturb                   */
  long ScriptMaskID;                      /* Script: Mask on ID of message to disturb           */
  BYTE ScriptRate;                        /* Script: Perturbation rate [0-255]                  */
  BYTE ScriptData[8];                     /* Script: Value of data to compare                   */
  BYTE ScriptMask[8];                     /* Script: Mask on the data byte to compare           */

  long ScriptIDNew;                       /* Script: New ID of message to disturb               */
  long ScriptMaskIDNew;                   /* Script: New mask on ID of message to disturb       */
  BYTE ScriptRateNew;                     /* Script: New perturbation rate [0-255]              */
  BYTE ScriptDataNew[8];                  /* Script: New value of data to compare               */
  BYTE ScriptMaskNew[8];                  /* Script: New mask on the data byte to compare       */

  BYTE stTRAM_ConfigID          = 0x00;   /* Variable for processing configuration of id's      */
  BYTE stTRAM_Script            = 0x00;   /* Variable for processing script configuration       */
  WORD ctTRAM_WaitOnReply       = 0x0000; /* Counter for missing reply from Traminator          */
}   
/*@@end*/

/*@@startStart:Start:*/
/*--------------------------------------------------------------------------*/
on start 
{

  int i, s, z;

  /* Max-Werte initialisieren */
  FOR (i=0; i < data_nr_max; i++)
  { 
     max_wert[i] = 0x7FFF; 
  }

  /* Weise Sende-Datum anhand seiner Nummer einen Namen zu */
  strncpy(data_name[Unused_Nr],             "< not used >",                 35);
  strncpy(data_name[Reserved_Nr],           "< reserved >",                 35);

  /* Copy names of Signals in Menue 0 (Transmission control and active nodes): */
  strncpy(data_name[Absent_Timer_Nr],       "Absent_Timer ",                35);
  strncpy(data_name[Absent_Info_Nr],        "Absent_Info  ",                35);
  strncpy(data_name[ABSactive_Nr],          "ABS active   ",                35);
  strncpy(data_name[BVMPAactive_Nr],        "BVMP active  ",                35);
  strncpy(data_name[CDSactive_Nr],          "CDS active   ",                35);
  strncpy(data_name[BSIactive_Nr],          "BSI active   ",                35);
  strncpy(data_name[Airbagactive_Nr],       "Airbag active",                35);
  strncpy(data_name[P__Elec_Int_Cntrl_Word_Nr],"P__Elec_Int_Cntrl_Word",    35);  
    
  /* Copy names of Signals in Menue 1 (messages Dyn_V2_BVMP 349): */
  //strncpy(data_name[P087_Nr],               "P087 Com_stClth",              35);
  strncpy(data_name[P009_Nr],               "P009 FrmMng_stGearShift",      35);
  strncpy(data_name[P057_Nr],               "P057 Com_trqTIIDes",           35);
  strncpy(data_name[P085_Nr],               "P085 Com_bGbxACCmprShOff",     35);
  strncpy(data_name[P167_Nr],               "P167 FrmMng_stEngSpdCtl",      35);
  strncpy(data_name[P287_Nr],               "P287 BV gear mechanically engaged",35);
  strncpy(data_name[P283_Nr],               "P283 target gear",             35);
  strncpy(data_name[Sim_counter_hang_349_Nr],"P230 counter hang simulation 349",35);
  strncpy(data_name[Sim_chksum_fault_349_Nr],"P340 chksum fault simulation 349",35);
  //strncpy(data_name[P055_Nr],               "P055 trqTCabs",                35);
  strncpy(data_name[P166_Nr],               "P166 Gbx_nTSCEngDem",          35);
  strncpy(data_name[P030_Nr],               "P030 Gbx_stDrvTrnEgd",         35);
  //strncpy(data_name[P361_Nr],               "P361 Com_stTSCEngDemTyp",      35);
  strncpy(data_name[P333_Nr],               "P333 Com_stGbxTrqIntv",        35);
  strncpy(data_name[P360_Nr],               "P360 Gbx_stIntvTyp",           35);
  strncpy(data_name[P362_Nr],               "P362 Com_bGearShftExpt",       35);
  strncpy(data_name[P440_Nr],               "P440 Com_bUCAPSWkUpReqRaw",    35);
            
  /* Copy names of Signals in Menue 2 (message Dat_BSI 412): */
  strncpy(data_name[P013_Nr],               "P013 Main Brake Switch",       35);
  strncpy(data_name[P040_Nr],               "P040 Main Brake Fault",        35);
  strncpy(data_name[P104_Nr],               "P104 Com_stAOHt",              35);
  strncpy(data_name[P086_Nr],               "P086 Com_stFlMinRls",          35);
  strncpy(data_name[P012_Nr],               "P012 Com_stFlMin",             35);
  strncpy(data_name[P298_Nr],               "P298 Req RTE Enable",          35);
  strncpy(data_name[P277_Nr],               "P277 Com_vOilLvlDem",          35);
  strncpy(data_name[P328_Nr],               "P328 Com_stEHRPmp",            35);
  strncpy(data_name[P103_Nr],               "P103 Com_bRevGear",            35);
  strncpy(data_name[P223_Nr],               "P223 Crash Info",              35);

  /* Copy names of Signals in Menue 3 (message Dat_BSI1 432): */
  /* Dat_BSI1 432 */
  strncpy(data_name[P214_Nr],               "P214 Com_stMnWkUp ",           35);  
  strncpy(data_name[P216_Nr],               "P216 Com_bSiaWkUp",            35);
  strncpy(data_name[P249_Nr],               "P249 Com_stEngStopReq",        35);
  // strncpy(data_name[P251_Nr],               "P251 Com_stScndStrtReq",       35);
  strncpy(data_name[P253_Nr],               "P253 Com_bEngPrepReq",         35);
  strncpy(data_name[P267_Nr],               "P267 Exh_volReFl",             35);
  strncpy(data_name[P274_Nr],               "P274 FrmMng_ctReFl",           35);
  strncpy(data_name[P276_Nr],               "P276 Com_bOilWkUp",            35);
  // strncpy(data_name[P255_Nr],               "P255 Com_tiSec",               35);  
  // strncpy(data_name[P256_Nr],               "P256 Com_tiDay",               35);
  // strncpy(data_name[P257_Nr],               "P257 Com_tiYr",                35);
  strncpy(data_name[P350_Nr],               "P350 Post ventilation wake up",35);
  strncpy(data_name[P367_Nr],               "P367 JDD context",             35);
  strncpy(data_name[P368_Nr],               "P368 SEV main state",          35);
  strncpy(data_name[P369_Nr],               "P369 electric network state",  35);
  strncpy(data_name[P402_Nr],               "P402 Start request",           35);
  strncpy(data_name[P403_Nr],               "P403 Start request status",    35);
  strncpy(data_name[P439_Nr],               "P439 UCAPS pre-/discharging wake up", 35);
  
  /* Dat_BSI1 432: */
  strncpy(data_name[P015_Nr],               "P015 Com_lTotDst",             35);
  strncpy(data_name[P325_Nr],               "P325 Com_tiEngOff",            35);
  strncpy(data_name[P326_Nr],               "P326 Com_ctTmrRst",            35);
  

  /* Copy names of Signals in Menue 4 (message Dat3_BSI 4F2, DAT7_BSI 612): */
  /* 4F2 */
  strncpy(data_name[P429_Nr],               "P429 Com_stSOCInfoInvldRaw",   35);
  strncpy(data_name[P435_Nr],               "P435 Com_stUCAPRechCrntRaw",   35);
  strncpy(data_name[P434_Nr],               "P434 Com_rBattChHiRes",        35);
  strncpy(data_name[P438_Nr],               "P438 Com_uBattIntRstnRaw",     35);
  strncpy(data_name[P437_Nr],               "P437 Com_uBattOpnCir",         35);
  strncpy(data_name[P493_Nr],               "P493 Com_stPrioVoltMin",       35);
  strncpy(data_name[P490_Nr],               "P490 Com_uVoltCtlProdMin",     35);
  strncpy(data_name[P494_Nr],               "P494 Com_stPrioVoltMax",       35);
  strncpy(data_name[P491_Nr],               "P491 Com_uVoltCtlProdMax",     35);
  strncpy(data_name[P492_Nr],               "P492 Com_uVarProdMax",         35);
  /* 612 */
  strncpy(data_name[P409_Nr],               "P409_Com_stRly3DiagRaw",       35);  
  
  
  /* Copy names of Signals in Menue 5 (message Dat_CLIM 50E): */
  // strncpy(data_name[P050_Nr],             "P050 Com_stAC",                35);
  strncpy(data_name[P164_Nr],               "P164 Com_stPFltFan",           35);
  strncpy(data_name[P046_Nr],               "P046 Com_rFanClgDem",          35);
  strncpy(data_name[P144_Nr],               "P144 Com_stPFltGlw",           35);
  strncpy(data_name[P189_Nr],               "P189 Com_stEEMIdlDem",         35);
  strncpy(data_name[P208_Nr],               "P208 Com_nACIdlDem",           35);
  strncpy(data_name[P209_Nr],               "P209 Com_stACRaw",             35);
  strncpy(data_name[P210_Nr],               "P210 Com_pwrACDem",            35);
  strncpy(data_name[P417_Nr],               "P417 Driver presence",         35);
  strncpy(data_name[P432_Nr],               "P432 Engine restart reqstd by HAB", 35);
  strncpy(data_name[P433_Nr],               "P433 Engine stop auth. by HAB", 35);


  /* Copy names of Signals in Menue 6  for cruise control */
  strncpy(data_name[P219_Nr],               "P219 FrmMng_vPrpReq ",         35);
  strncpy(data_name[P220_Nr],               "P220 FrmMng_stPrpReq",         35);
  strncpy(data_name[P221_Nr],               "P221 Speed setpoint Typ ",     35);
  strncpy(data_name[P222_Nr],               "P222 Typ of PrpCtl Req",       35);
  strncpy(data_name[P231_tx_Zero_Cnt_Nr],   "P231 Count value to send '0' cnt",35);
  strncpy(data_name[P231_Typ_Cnt_Nr],       "P231 Cnt Type 0-old,1- 0..0,13,15,1.. 2 - Odd cnt 3 - Even Cnt ",35);
  strncpy(data_name[P231_CntrHang_Nr],      "P231 CrCtl Cntr Hang",         35);
  strncpy(data_name[P232_InVld_Nr],         "P232 checksum hang",           35);
  strncpy(data_name[CrCtl_Select_Nr],       "CrCtl_SL_Select",              35);
 

  /* Copy names of Signals in Menue 7 (message Dyn_CDS ID 34D): */
  strncpy(data_name[P047_Nr],               "P047 Com_stESPIntv",           35);
  strncpy(data_name[P147_Nr],               "P147 Com_bESPIntvActv",        35);
  strncpy(data_name[CounterFault_Nr],       "Fault Counter hanging",        35);
  strncpy(data_name[TCSStatFault_Nr],       "Fault TCS stat. torque",       35);
  strncpy(data_name[TCSDynFault_Nr],        "Fault TCS dyn. torque",        35);
  strncpy(data_name[DCSFault_Nr],           "Fault DCS torque",             35);
  strncpy(data_name[P043_Nr],               "P043 Com_xTCSStatRaw",         35);
  strncpy(data_name[P044_Nr],               "P044 Com_trqTCSRaw",           35);
  strncpy(data_name[P045_Nr],               "P045 Com_trqDCSRaw",           35);

  
  /* Copy names of Signals in Menue 8 (messages Dyn_ABR 38D): */
  strncpy(data_name[P010_Nr],               "P010 Com_v    ",               35);
  strncpy(data_name[P052_Nr],               "P052 Com_aLng",                35);
  strncpy(data_name[P688_Nr],               "P688 Hill assist stop auth. STT", 35);
  strncpy(data_name[P225_Nr],               "P225 Com_stBrkRaw.0",          35);
  strncpy(data_name[P224_Nr],               "P224 Com_stBrkRaw.1",          35);
  strncpy(data_name[P226_Nr],               "P226 Com_stBrkActv",           35);
  strncpy(data_name[P319_Nr],               "P319 Clutch Pedal position ",  35);
  strncpy(data_name[P515_Nr],               "P515 TMC pressure ",           35);

  
  /* Copy names of Signals in Menue 9 (message CONTEXTE1 ID 7F2/5B2): */
  //AEE2007 strncpy(data_name[P__Diagnostic_On_Can_Nr],"P__Diagnostic_On_Can",        35);
  //AEE2007 strncpy(data_name[P__Local_ID_Nr],        "P__Local_ID",     35);    
  //AEE2007 strncpy(data_name[P015_Nr],               "P015 Com_lTotDst",             35); 
  strncpy(data_name[P100_Nr],               "P100 FrmMng_stAddPmpDef",      35);        
  strncpy(data_name[P146_Nr],               "P146 Com_tEnvT",               35);           
  strncpy(data_name[P__Com_stEOBD_Nr],      "P__Etat_info_EOBD_BSI",        35);
  
  
  /* Copy names of Menue 10 (message Dat_V2_BV 489, Dyn_EasyMove 3AD */
  strncpy(data_name[P218_Nr],               "P218 Com_stDrvIdx",            35);  
  strncpy(data_name[P282_Nr],               "P282 Com_stGbxErr",            35);  
  strncpy(data_name[P285_Nr],               "P285 Com_bPNDia",              35);        
  strncpy(data_name[P029_Nr],               "P029 Com_stPrg",               35);       
  strncpy(data_name[P374_Nr],               "P374 Com_bOBDNoRdy",           35);  
  strncpy(data_name[P375_Nr],               "P375 Com_bMILDem",             35);        
  strncpy(data_name[P376_Nr],               "P376 Com_bMILCntRstDemRaw",    35);       

  /* Menue 10 (message Dyn2_V2_BV ID 3C9, Dyn_EasyMove ID 0x3AD ) */
  // strncpy(data_name[P363_Nr],               "P363 Com_trqRelCrSConv",       35); /* from Dyn2_BV */
  strncpy(data_name[Sim_counter_hang_3C9_Nr], "P230 counter hang simulation 3C9", 35);           
  strncpy(data_name[Sim_chksum_fault_3C9_Nr], "P340 checksum fault simulation 3C9", 35);
  // strncpy(data_name[P364_Nr],               "P364 Gbx_nGbxIPSpeedFlt",      35);  
  /* 3C9 */
  strncpy(data_name[P291_Nr],               "P291 Maximum torque from clutch", 35); 
  strncpy(data_name[P293_Nr],               "P293 Engine off request from BV", 35); 
  /* 3AD */
  strncpy(data_name[P299_Nr],               "P299 Com_bCrCtlInhib",         35);
  strncpy(data_name[P337_Nr],               "P337 Com_stPrkBrk",            35);

  
  /* Copy names of Menue 11 (message Dat6_BSI 592, Dyn4_FRE 30D, Vroues_ABR 44D) */
  /* 592 */
  strncpy(data_name[P272_Nr],               "P272 Com_rBattCh",             35);
  strncpy(data_name[P273_Nr],               "P273 Com_tBatt",               35);           
  strncpy(data_name[P349_Nr],               "P349 EEM_stAltCtlType",        35);  
  strncpy(data_name[P418_Nr],               "P418 BECB battery voltage",               35);
  strncpy(data_name[P419_Nr],               "P419 STT state change request",           35);
  strncpy(data_name[P420_Nr],               "P420 Battery current's measmnt caliber",  35);
  strncpy(data_name[P421_Nr],               "P421 Battery current",                    35);
  
  /**/
  strncpy(data_name[P263_Nr],               "P263 VehV_vPsvValWhlFrtL",     35);  
  strncpy(data_name[P264_Nr],               "P264 VehV_vPsvValWhlFrtR",     35);  
  /* 44D */
  strncpy(data_name[P330_Nr],               "P330 VehV_vWhlRrL",            35);
  strncpy(data_name[P331_Nr],               "P331 VehV_vWhlRrR",            35);
  strncpy(data_name[P354_Nr],               "P354 VehV_nWhlAvrg",           35);
  /* 50D */
  strncpy(data_name[P351_Nr],               "P351 ABS intervention active",     35);
  strncpy(data_name[P415_Nr],               "P415 brake function for STT need", 35);
  
  
  /* Copy names of Menue 12 (message Dyn_STT_BV 329, DAT_DIRA 495)  */
  /* 329 */
  strncpy(data_name[P441_Nr],               "P441 Com_bGbxAuthRstrtRaw",    35);
  strncpy(data_name[P442_Nr],               "P442 Com_bGbxAuthStopRaw ",    35);
  strncpy(data_name[P443_Nr],               "P443 Com_bGbxRstrtReq    ",    35);
  strncpy(data_name[P444_Nr],               "P444 Com_bGbxSysFaultRaw ",    35);
  strncpy(data_name[Sim_counter_hang_329_Nr],"P230 counter hang simulation 329",   35);
  strncpy(data_name[Sim_chksum_fault_329_Nr],"P340 checksum fault simulation 329", 35);
  //strncpy(data_name[P340_329_Nr],           "P340_Com_xChkSum2        ",    35);
  /* 495 */
  strncpy(data_name[P447_Nr],               "P447 Engine restart reqstd by DA",35);
  strncpy(data_name[P448_Nr],               "P448 Engine stop author. by DA ", 35);


  
  /* Min-, Max-Werte fuer Daten aendern */
  min_wert[Absent_Timer_Nr]       = 0;
  max_wert[Absent_Info_Nr]        = 1;

  max_wert[ABSactive_Nr]          = 1;
  max_wert[BVMPAactive_Nr]        = 1;
  max_wert[CDSactive_Nr]          = 1;
  max_wert[BSIactive_Nr]          = 1;
  max_wert[Airbagactive_Nr]       = 1;
  max_wert[P__Elec_Int_Cntrl_Word_Nr]= 0xFF;
  

  /* Maximum values for signals in message Dyn_V2_BVMP 349: */

  //max_wert[P087_Nr]             = 0x03;     /* Clutch state */
  max_wert[P009_Nr]             = 1;        /* shifting in progress FrmMng_stGearShift */
  max_wert[P030_Nr]             = 0x03;     /* P030 Gbx_stDrvTrnEgd */
  max_wert[P057_Nr]             = 0xFF;     /* Torque intv */  
  max_wert[P085_Nr]             = 1;        /* AC compressor inhibit FrmMng_stReqFrzACC  */
  max_wert[P167_Nr]             = 1;        /* Engine speed control */
  max_wert[P287_Nr]             = 0x0F;     /* Gear engaged */
  max_wert[P283_Nr]             = 0x0F;     /* target gear */
  max_wert[Sim_counter_hang_349_Nr] = 0x10; /* counter hang simulation P230 */
  max_wert[Sim_chksum_fault_349_Nr] = 0x0F; /* checksum faulty simulation P340 */
  max_wert[P229_Nr]             = 0x0F;     /* checksum from BVMP */
  //max_wert[P055_Nr]             = 0xFF;     /* Torque limitation for gear box / Absolute torque request */
  max_wert[P166_Nr]             = 0xFF;     /* Desired engine speed  */     
  max_wert[P333_Nr]             = 0x03;     /* P333 Com_stGbxTrqIntv, gearshift phase */
  max_wert[P360_Nr]             = 0x07;     /* P360 Gbx_stIntvTyp, Gearbox intv type */
  max_wert[P362_Nr]             = 0x01;     /* P362 Com_bGearShftExpt, ABS intv active */
  max_wert[P440_Nr]             = 0x07;     /* P440_Com_bUCAPSWkUpReqRaw */

  /* Maximum values for signals in message Dat_BSI 412: */

  max_wert[P013_Nr]             = 0x01;     /* main break switch */
  max_wert[P040_Nr]             = 0x01;     /* Main break switch is defect.*/
  max_wert[P104_Nr]             = 0x03;     /* FrmMng_stAOHt */
  max_wert[P086_Nr]             = 0x03;     /* FrmMng_stFlMinRls Minimum fuel level is valid.*/
  max_wert[P012_Nr]             = 0x01;     /* FrmMng_stFlMin Minimum fuel level is detected. */
  max_wert[P298_Nr]             = 0x01;     /* Req to enable RTE Function */
  max_wert[P103_Nr]             = 0x01;     /* Reverse gear status */
  max_wert[P277_Nr]             = 0x01;     /* Req to measure oil level */
  max_wert[P328_Nr]             = 0x03;     /* Water pump status RTE V63 */

  /* Maximum values for signals in message Dat_BSI1 432: */

  max_wert[P214_Nr]             = 0x03;     /*  Main wake-up (RCD ) */ 
  max_wert[P216_Nr]             = 0x01;     /*  Immobilizer anticipation with wake up  */
  max_wert[P249_Nr]             = 0x03;     /*  Engine stop request */
  max_wert[P251_Nr]             = 0x03;     /*  Secondary latched starting request */
  max_wert[P253_Nr]             = 0x01;     /*  Engine preparation request */
  max_wert[P267_Nr]             = 0xFF;     /*  Refuel volume */
  max_wert[P274_Nr]             = 0x07;     /*  Refueling counter */
  max_wert[P276_Nr]             = 0x01;     /*  Starter oil measuring Wake-Up */
  // max_wert[P255_Nr]             = 0xFFFFF;  /*  P255_Com_tiSec                */
  // max_wert[P256_Nr]             = 0xFFF;    /*  P256_Com_tiDay                */
  // max_wert[P257_Nr]             = 0xFF;     /*  P257_Com_tiYr                 */
  max_wert[P350_Nr]             = 0x01;     /* Post ventilation wake up */
  max_wert[P367_Nr]             = 0x3F;     /* JDD context */
  max_wert[P368_Nr]             = 0x03;     /* SEV main state */
  max_wert[P369_Nr]             = 0x0F;     /* electricnetwork state */
  max_wert[P402_Nr]             = 0x03;     /* Start request */
  max_wert[P403_Nr]             = 0x01;     /* Start request status */
  max_wert[P439_Nr]             = 0x01;     /* UCAPS precharging/discharging wake up */

  /* Maximum values for signals in message Dat3_BSI 4F2: */
  max_wert[P429_Nr]             = 0x03;     /* P429_Com_stSOCInfoInvldRaw */
  max_wert[P435_Nr]             = 0x03;     /* P435_Com_stUCAPRechCrntRaw  */
  max_wert[P434_Nr]             = 0x03FF;   /* P434_Com_rBattChHiRes  */
  max_wert[P438_Nr]             = 0x03FF;   /* P438_Com_uBattIntRstnRaw  */
  max_wert[P437_Nr]             = 0x01FF;   /* P437_Com_uBattOpnCir  */
  max_wert[P493_Nr]             = 0x03;     /* P493_Com_stPrioVoltMin  */
  max_wert[P490_Nr]             = 0x3F;     /* P490_Com_uVoltCtlProdMin  */
  max_wert[P494_Nr]             = 0x03;     /* P494_Com_stPrioVoltMax  */
  max_wert[P491_Nr]             = 0x3F;     /* P491_Com_uVoltCtlProdMax  */
  max_wert[P492_Nr]             = 0x7F;     /* P492_Com_uVarProdMax  */

  /* Maximum values for signals in message Dat3_BSI 4F2: */
  max_wert[P409_Nr]             = 0x07;     /* P409_Com_stRly3DiagRaw */
  

  /* Maximum values for signals in message Dat_CLIM 50E: */
  //max_wert[P050_Nr]             = 0x01;     /* demand for air conditioning by driver AC-TH */
  max_wert[P164_Nr]             = 0x03;     /* fan speed binary request by AC FrmMng_stPFltFan */
  max_wert[P046_Nr]             = 0x3F;     /* fan speed proportional request by AC FrmMng_rFanMinAC */
  max_wert[P144_Nr]             = 0x01;     /* FrmMng_stPFltGlw Forcage_Encl_Bougies */
  max_wert[P189_Nr]             = 7;
  max_wert[P209_Nr]             = 1;
  max_wert[P210_Nr]             = 0xFF;
  max_wert[P219_Nr]             = 0xFF; 
  max_wert[P220_Nr]             = 0x01; 
  max_wert[P221_Nr]             = 0x03; 
  max_wert[P222_Nr]             = 0x01; 
  max_wert[P231_tx_Zero_Cnt_Nr] = 0xFF; 
  max_wert[P231_Typ_Cnt_Nr]     = 0x03; 
  max_wert[P232_Nr]             = 0x03; 
  max_wert[P223_Nr]             = 0x01;     /* Crash info about Airbag from the Body Car ECU */
  max_wert[CrCtl_Select_Nr]     = 0x06;
  max_wert[P417_Nr]             = 0x03;     /* STT Driver presence */
  max_wert[P432_Nr]             = 0x01;     /* STT Engine restart requested by sub system HAB */
  max_wert[P433_Nr]             = 0x01;     /* STT Engine stop authorization by sub system HAB */  
  

  /* Maximum values for signals in message Dyn_CDS 34D: */
  max_wert[P047_Nr]             = 0x07;     /* ESP torque request status */
  max_wert[P147_Nr]             = 0x01;     /* ESP TCS (ASR) in regulation */
  max_wert[CounterFault_Nr]     = 1;        /* ESP simulation counter is hanging */
  max_wert[TCSStatFault_Nr]     = 1;        /* ESP simulation of invalid TCS static torque */
  max_wert[TCSDynFault_Nr]      = 1;        /* ESP simulation of invalid TCS dynamic torque */
  max_wert[DCSFault_Nr]         = 1;        /* ESP simulation of invalid DCS torque */
  max_wert[P043_Nr]             = 0xFF;     /* ESP TCS (ASR) static torque request */
  max_wert[P044_Nr]             = 0xFF;     /* ESP TCS (ASR) dynamic torque request */
  max_wert[P045_Nr]             = 0xFF;     /* ESP DCS (MSR) torque request */

  /* Maximum values for signals in message Dyn_ABR 38D: */
  max_wert[P010_Nr]             = 0xFFFF;   /* ABS velocity     */
  max_wert[P052_Nr]             = 0xFF;     /* ABS acceleration */
  max_wert[P688_Nr]             = 0x01;     /* Hill assist stop authorization for STT */
  max_wert[P225_Nr]             = 1;        /* Brake pedal switch*/
  max_wert[P224_Nr]             = 1;        /* Brake pedal fault */
  max_wert[P226_Nr]             = 3;        /* Braking in action */
  max_wert[P319_Nr]             = 0xFF;     /* Clutch pedal position */
  max_wert[P515_Nr]             = 0x0FFF;   /* TMC pressure */

  /* Maximum values for signals in message CONTEXTE1: */
  // AEE2007 max_wert[P__Diagnostic_On_Can_Nr]= 0xFF;
  // AEE2007 max_wert[P__Local_ID_Nr]      = 0xFF;
  // AEE2007 max_wert[P015_Nr]             = 0x00FFFFFF; /* BSI odometer (distance on dash-board) */
  max_wert[P100_Nr]             = 0xFF;     /* FrmMng_stAddPmpDef Status of additive */
  max_wert[P146_Nr]             = 0xFF;     /* Environment air temperature */
  max_wert[P__Com_stEOBD_Nr]    = 0xFF;     /* state of EOBD info */

  /* Maximum values for signals in message Dat_V2_BV 489 */
  max_wert[P218_Nr]             = 0xFF;     /* Driving type/ Sportive index */
  max_wert[P029_Nr]             = 0x03;
  max_wert[P282_Nr]             = 0x0F;     /* BVA error states  */
  max_wert[P285_Nr]             = 0x01;     /* Start Inhibition request from AM6  */
  max_wert[P374_Nr]             = 0x01;     /* Readiness flag not set for OBD errors on Gbx */
  max_wert[P375_Nr]             = 0x01;     /* MIL request */
  max_wert[P376_Nr]             = 0x01;     /* Clear MIL KM counter */

  /* Maximum values for signals in message Dyn2_V2_BV 3C9 */
  max_wert[P299_Nr]             = 0x01;
  max_wert[P337_Nr]             = 0x07;   
  max_wert[Sim_counter_hang_3C9_Nr] = 0x10; /* counter hang simulation P230 */
  max_wert[Sim_chksum_fault_3C9_Nr] = 0x0F; /* checksum fault simulation P340 */
  
  
//  /* Maximum values for signals in message (message Dyn5_CMM 228)  */
//  max_wert[P320_Nr]             = 0xFF;     /* P320_EasyMvTrqInfo */
//  max_wert[P321_Nr]             = 0x03;     /* P321_StatusOfEasyMvTrq */
//  max_wert[P334_Nr]             = 0xFF;     /* P334_ACCPed_Position */
//  max_wert[P335_Nr]             = 0x0F;     /* P335_Com_ctDyn5CMMCntr */
//  max_wert[P336_Nr]             = 0x0F;     /* P336_Com_xDyn5CMMChkSum */
//  max_wert[P388_Nr]             = 0xFF;     /* P388_Com_rClthPedPos */
//  max_wert[P410_Nr]             = 0x01;     /* P410_Com_stEngTrqStSp */
//  max_wert[P411_Nr]             = 0x01;     /* P411_Com_stTrqAvlStSp */

  
  /* Maximum values for signals in message Dyn_STT_BV 329: */
  max_wert[P441_Nr]             = 0x01;    /* P441_Com_bGbxAuthRstrtRaw */
  max_wert[P442_Nr]             = 0x01;    /* P442_Com_bGbxAuthStopRaw  */
  max_wert[P443_Nr]             = 0x01;    /* P443_Com_bGbxRstrtReq     */
  max_wert[P444_Nr]             = 0x01;    /* P444_Com_bGbxSysFaultRaw  */
  max_wert[Sim_counter_hang_329_Nr] = 0x10; /* counter hang simulation P230 */
  max_wert[Sim_chksum_fault_329_Nr] = 0x0F; /* checksum fault simulation P340 */
  
//  /* Maximum values for signals in message Dyn_STT_CMM 3C8: */
//  max_wert[P412_Nr]             = 0x03;    /* P412_Com_stDeadPnt */
//  max_wert[P428_Nr]             = 0x03;    /* P428_Com_stCDTReq */
  
  
  /* Maximum values for signals in message DAT_DIRA 495: */ 
  max_wert[P447_Nr]             = 0x01;     /* P447_Com_bStrgWhlEngRstrtReqRaw */
  max_wert[P448_Nr]             = 0x01;     /* P448_Com_bStrgWhlEngStopReqRaw  */
  
  /* Maximum values for signals in message Dat_ABR 50D: */ 
  max_wert[P351_Nr]              = 0x01;        /* P351 ABS intervention active */
  max_wert[P415_Nr]              = 0x03;        /* P415 brake function for STT need*/
          
  /* Maximum values for signals in message Dat4_BSI 552 AEE2010: */ 
  max_wert[P015_Nr]              = 0xFFFFFF;    /* P015_Com_lTotDst */
  max_wert[P325_Nr]              = 0xFFFFFFFF;  /* P325_Com_tiEngOff */
  max_wert[P326_Nr]              = 0xFF;        /* P326_Com_ctTmrRst */
     
  /* Maximum values for signals in message Dat6_BSI 592: */ 
  max_wert[P272_Nr]              = 0xFF;        /* Percentage of battery charge */ 
  max_wert[P273_Nr]              = 0xFF;        /* Battery temperature */ 
  max_wert[P349_Nr]              = 0x07;        /* Alternator control Type */
  max_wert[P418_Nr]              = 0x07FF;      /* BECB battery voltage */
  max_wert[P419_Nr]              = 0x03;        /* STT state change request */
  max_wert[P420_Nr]              = 0x03;        /* Battery current's measurement caliber */
  max_wert[P421_Nr]              = 0xFFFF;      /* Battery current */
          
  
/*------------------------------------------------------------------------------------------------*/
  
  /* Weise Sende-Message anhand seiner Nummer einen Namen zu */
  strncpy(tx_msg_name[Dyn_V2_BVMP_Nr],         "Dyn_V2_BVMP", 35);
  strncpy(tx_msg_name[DAT_BSI_Nr],             "Dat_BSI",     35);
  strncpy(tx_msg_name[DAT_CLIM_Nr],            "Dat_CLIM",    35);
  strncpy(tx_msg_name[DYN_CDS_Nr],             "Dyn_CDS",     35);
  strncpy(tx_msg_name[DYN_ABR_Nr],             "Dyn_ABR",     35);
  strncpy(tx_msg_name[CONTXT1_Nr],             "CONTXT1_5B2", 35);              
  strncpy(tx_msg_name[CRASH_Nr],               "Etat_Crash",  35); 
  strncpy(tx_msg_name[DYN2_FRE_Nr],            "Dyn2_FRE",    35);                
  strncpy(tx_msg_name[DAT_BSI1_Nr],            "Dat_BSI1",    35);                  
  strncpy(tx_msg_name[DAT4_BSI_Nr],            "Dat4_BSI",    35);                  
  strncpy(tx_msg_name[Dat6_BSI_Nr],            "Dat6_BSI",    35);
  strncpy(tx_msg_name[Dyn4_FRE_Nr],            "Dyn4_FRE",    35);
  strncpy(tx_msg_name[Vroues_ABR_Nr],          "Vroues_ABR",  35);
  strncpy(tx_msg_name[Dat_ABR_Nr],             "Dat_ABR",     35);
  strncpy(tx_msg_name[DAT3_BSI_Nr],            "Dat3_BSI",    35);
  strncpy(tx_msg_name[DAT7_BSI_Nr],            "Dat7_BSI",    35);
  strncpy(tx_msg_name[Dat_V2_BV_Nr],           "Dat_V2_BV",   35);
  
/*------------------------------------------------------------------------------------------------*/

  /* Message-Feld definieren */
  SendMsg[Dyn_V2_BVMP_Nr]                   = DYN_V2_BVMP;
  SendMsg[DAT_BSI_Nr]                       = DAT_BSI;
  SendMsg[DAT_CLIM_Nr]                      = DAT_CLIM;
  SendMsg[DYN_CDS_Nr]                       = DYN_CDS;
  SendMsg[DYN_ABR_Nr]                       = DYN_ABR;
  SendMsg[CONTXT1_Nr]                       = CONTXT1;                  
  SendMsg[CRASH_Nr]                         = CRASH;
  SendMsg[DYN2_FRE_Nr]                      = DYN2_FRE;
  SendMsg[DAT_BSI1_Nr]                      = DAT_BSI1;
  SendMsg[DAT4_BSI_Nr]                      = DAT4_BSI;
  SendMsg[Dat6_BSI_Nr]                      = Dat6_BSI;
  SendMsg[Dyn4_FRE_Nr]                      = Dyn4_FRE;
  SendMsg[Vroues_ABR_Nr]                    = Vroues_ABR;
  SendMsg[Dat_ABR_Nr]                       = Dat_ABR;
  SendMsg[DAT3_BSI_Nr]                      = DAT3_BSI;
  SendMsg[DAT7_BSI_Nr]                      = DAT7_BSI;
  SendMsg[Dat_V2_BV_Nr]                     = Dat_V2_BV;

/*------------------------------------------------------------------------------------------------*/

  /* Initialise simulated nodes */
  data[ABSactive_Nr]                        = 1;
  data[BVMPAactive_Nr]                      = 1;        /* BVMP active as default */
  data[CDSactive_Nr]                        = 1;
  data[BSIactive_Nr]                        = 1;
  data[Airbagactive_Nr]                     = 0;
  

  /* Initialise signals in message Dyn_V2_BVMP 349: */

  /* Initialise signals in message CRASH 4C8: */
  data[P223_Nr]                             = 1;        /* Crash info about Airbag from the Body Car ECU */

  /* Initialise Signals in message Dat_BSI1 432: */
  data[P214_Nr]               = 1;
  data[P249_Nr]               = 1;
  data[P251_Nr]               = 1;

  /* Initialise Signals in message Dat_BSI4 : */
  // data[P255_Nr]               = 0;
  // data[P256_Nr]               = 0;
  // data[P257_Nr]               = 0;

    
  /* Initialise signals in message Dat_CLIM: */
  DataCounter_CrCtl = 0x00;
  data[P231_tx_Zero_Cnt_Nr] = 0 ;
  data[P231_Typ_Cnt_Nr] = 0 ;
  
  /* Initialise signals in message Dyn_CDS: */
  data_Counter                              = 0;        /* ESP message counter */

  
  /* Initialise signals in messages Dyn_ABR 38D */

  data[P052_Nr]                             = 175;      /* P052 ABS acceleration = 0.0 m/s^2 */

  /* Initialise signals in message CONTEXTE1: */
  //count_CONTXT1 = 0;                                    /* Botschaftszaehler initialisieren */
  //data[P__Diagnostic_On_Can_Nr]             = 0x61;                                                   
  //data[P__Local_ID_Nr]                      = 0x8E;     /* Local ID für Additiv-Info in Byte[5..3] */ 

  data[P015_Nr]                             = 0x01860F; /* Odometer (BSI) */ 

  /* Bytes der Sende-Botschaften grundinitialisieren  */
  FOR (i=0; i < tx_msg_nr_max; i++)
  { 
     SendMsg[i].byte(0) = 0xFF; 
     SendMsg[i].byte(1) = 0xFF; 
     SendMsg[i].byte(2) = 0xFF; 
     SendMsg[i].byte(3) = 0xFF; 
     SendMsg[i].byte(4) = 0xFF; 
     SendMsg[i].byte(5) = 0xFF; 
     SendMsg[i].byte(6) = 0xFF; 
     SendMsg[i].byte(7) = 0xFF; 
  }

  /* bestimme letzte aktive Zeile innerhalb einer Spalte */ 
  for (s=0; s < spalten_max; s++)
  { 
    letzte_zeile[s] = 0;
    for (z=0; z < zeilen_max; z++)
    {
      if ((data_tab[s][z] != Unused_Nr) && (data_tab[s][z] != Reserved_Nr))
      {
        letzte_zeile[s] = z;    /* Zeile aktiv */
      }
    }
  }

  /* Initialise variables for message monitoring. */
  /* Array construction: mon_period[x][0] = number of message hits                  */
  /*                                  [1] = last time the message was received      */
  /*                                  [2] = sum of period time                      */
  /*                                  [3] = minimum period time                     */
  /*                                  [4] = maximum period time                     */
  /*                                  [5] = Marker request for displaying results   */
  for (i = 0 ; i < rx_msg_nr_max ; i++)
  {
    mon_period[i][MON_MIN] = 0x7FFFFFFF;                        /* Set to infinity for minimum  */
    mon_period[i][MON_HITS]= 0x7FFFFFFF;                        /* Disable monitoring for       */
                                                                /* period time measurement.     */
  }

  /* Initialise names of receive messages */
  strncpy(rx_msg_name[RX_RQD_CMM],          "RQD_CMM",      35); 
  strncpy(rx_msg_name[RX_VERS_CMM],         "Vers_CMM",     35);
  strncpy(rx_msg_name[RX_DYN_CMM],          "Dyn_CMM",      35); 
  strncpy(rx_msg_name[RX_DYN2_CMM],         "Dyn2_CMM",     35); 
  strncpy(rx_msg_name[RX_DYN_VEH],          "Dyn_Veh",      35); 
  strncpy(rx_msg_name[RX_DAT_CMM],          "Dat_CMM",      35); 
  strncpy(rx_msg_name[RX_SUPV_CMM],         "Supv_CMM",     35); 
  strncpy(rx_msg_name[RX_DYN3_CMM],         "Dyn3_CMM",     35); 
  strncpy(rx_msg_name[RX_BSI_FaultLog],     "BSI_FaultLog", 35); 
  strncpy(rx_msg_name[RX_EOBD_CMM],         "EOBD_CMM",     35); 
  strncpy(rx_msg_name[RX_Dat2_CMM],         "Dat2_CMM",     35); 
  strncpy(rx_msg_name[RX_Dat3_CMM],         "Dat3_CMM",     35); 
  strncpy(rx_msg_name[RX_Dyn5_CMM],         "Dyn5_CMM",     35); 
  strncpy(rx_msg_name[RX_Dyn_STT_CMM],      "Dyn_STT_CMM",  35); 

   
  
  /* Initialise variables for Traminator control */
  ID_Cde    = TRAM_ID_CDE;                /* Identifier read from Traminator (ID command)       */
  ID_Status = TRAM_ID_STATUS;             /* Identifier read from Traminator (ID replies)       */

  /* Initialise the flag to disturb dyn_bva (0x349) */
  Timer_DynBVA_Flag = 0;    /* No disturbance */

  /* Timer aufsetzen */
  setTimer(timer10ms, 10);
  setTimer(timer20ms, 20);
  setTimer(timer40ms, 40);
  setTimer(timer50ms, 50);
  setTimer(timer60ms, 60);
  setTimer(timer100ms,100);
  //setTimer(timer250ms,250);
  setTimer(timer_mon500ms,500);                  
  setTimer(timer1000ms,1000);                  
  setTimer(timer_dynbva,0, 10000*1000);
  /* Commands to the write window */
  write(" Press key 'HOME' in order to send the Negative acknowledgement for BSI_faultLog ");
  write(" Press key 'z' in order to send the frame 0x349 with a tolerance of +/- 10 prct ");
  write(" Press key 'Z' in order to revert back the frame 0x349 to its exact schedule of 10ms");
  write(" Press key 'h' for key usage");
  write("");

}
/*@@end*/

/*@@caplFunc:MON_ErrorMessage(byte,byte):*/
/*------------------------------------------------------------------------------------------------*/
/*================================================================================================*/
/* Monitoring of receive messages */
/*================================================================================================*/

/*--------------------------------------------------------------------------*/
void MON_ErrorMessage (BYTE mon_rx_msg_no,
                       BYTE mon_errortype)
{
  if (!FrameMonActv)
  {
    return;  
  }
  
  write ("");
  switch (mon_errortype)
  {
    case (1):
      write ("ID of message %s is not like specified!", rx_msg_name[mon_rx_msg_no]); break;
    case (2):
      write ("DLC of message %s is not like specified!", rx_msg_name[mon_rx_msg_no]); break;
    default:
      write ("Unknown error type reported."); break;
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::RQD_CMM (0x72):*/
/*--------------------------------------------------------------------------*/
on message CAN1.RQD_CMM {
  long delta_t;
  float avg_period_time;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_RQD_CMM][MON_ID])
  {
    MON_ErrorMessage(RX_RQD_CMM, 1);
  }
  else 
  {
    if (mon_period[RX_RQD_CMM][MON_HITS] < (PARAMETERS[RX_RQD_CMM][MON_COUNT] + 2))
    {
      if (this.DLC != PARAMETERS[RX_RQD_CMM][MON_DLC])
      {
        MON_ErrorMessage(RX_RQD_CMM, 2);
      }
      else
      {
        mon_period[RX_RQD_CMM][MON_HITS]++;                     /* Increment receive counter    */

        delta_t = this.TIME - mon_period[RX_RQD_CMM][MON_LAST]; /* Calculate period time        */
        mon_period[RX_RQD_CMM][MON_LAST] = this.TIME;           /* Store last time              */
            
        if (mon_period[RX_RQD_CMM][MON_HITS] > 2)               /* Skip first measurement!      */
        {
          mon_period[RX_RQD_CMM][MON_SUM] = mon_period[RX_RQD_CMM][MON_SUM] + delta_t;
          
          if (delta_t < mon_period[RX_RQD_CMM][MON_MIN])        /* Check for minimum found      */
          {
            mon_period[RX_RQD_CMM][MON_MIN] = delta_t;
          }
          else if (delta_t > mon_period[RX_RQD_CMM][MON_MAX])   /* Check for maximum found      */
          {
            mon_period[RX_RQD_CMM][MON_MAX] = delta_t;
          }
        }
      }
    }
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Vers_CMM (0x108):*/
/*--------------------------------------------------------------------------*/
on message CAN1.Vers_CMM {
  write("");
  write("Version CMM was received at %f [s]",((float)this.time)/100000);

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_VERS_CMM][MON_ID])
  {
    MON_ErrorMessage(RX_VERS_CMM, 1);
  }
  else if (this.DLC != PARAMETERS[RX_VERS_CMM][MON_DLC])
  {
    MON_ErrorMessage(RX_VERS_CMM, 2);
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Dyn_CMM (0x208):*/
/*--------------------------------------------------------------------------*/
on message CAN1.Dyn_CMM {
  long delta_t;
  float avg_period_time;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_DYN_CMM][MON_ID])
  {
    MON_ErrorMessage(RX_DYN_CMM, 1);
  }
  else 
  {
    if (mon_period[RX_DYN_CMM][MON_HITS] < (PARAMETERS[RX_DYN_CMM][MON_COUNT] + 2))
    {
      if (this.DLC != PARAMETERS[RX_DYN_CMM][MON_DLC])
      {
        MON_ErrorMessage(RX_DYN_CMM, 2);
      }
      else
      {
        mon_period[RX_DYN_CMM][MON_HITS]++;                     /* Increment receive counter    */

        delta_t = this.TIME - mon_period[RX_DYN_CMM][MON_LAST]; /* Calculate period time        */
        mon_period[RX_DYN_CMM][MON_LAST] = this.TIME;           /* Store last time              */
            
        if (mon_period[RX_DYN_CMM][MON_HITS] > 2)               /* Skip first measurement!      */
        {
          mon_period[RX_DYN_CMM][MON_SUM] = mon_period[RX_DYN_CMM][MON_SUM] + delta_t;
          
          if (delta_t < mon_period[RX_DYN_CMM][MON_MIN])        /* Check for minimum found      */
          {
            mon_period[RX_DYN_CMM][MON_MIN] = delta_t;
          }
          else if (delta_t > mon_period[RX_DYN_CMM][MON_MAX])   /* Check for maximum found      */
          {
            mon_period[RX_DYN_CMM][MON_MAX] = delta_t;
          }
        }
      }
    }
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Dyn2_CMM (0x348):*/
/*--------------------------------------------------------------------------*/
on message CAN1.Dyn2_CMM {
  long delta_t;
  float avg_period_time;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_DYN2_CMM][MON_ID])
  {
    MON_ErrorMessage(RX_DYN2_CMM, 1);
  }
  else 
  {
    if (mon_period[RX_DYN2_CMM][MON_HITS] < (PARAMETERS[RX_DYN2_CMM][MON_COUNT] + 2))
    {
      if (this.DLC != PARAMETERS[RX_DYN2_CMM][MON_DLC])
      {
        MON_ErrorMessage(RX_DYN2_CMM, 2);
      }
      else
      {
        mon_period[RX_DYN2_CMM][MON_HITS]++;                    /* Increment receive counter    */

        delta_t = this.TIME - mon_period[RX_DYN2_CMM][MON_LAST];/* Calculate period time        */
        mon_period[RX_DYN2_CMM][MON_LAST] = this.TIME;          /* Store last time              */
            
        if (mon_period[RX_DYN2_CMM][MON_HITS] > 2)              /* Skip first measurement!      */
        {
          mon_period[RX_DYN2_CMM][MON_SUM] = mon_period[RX_DYN2_CMM][MON_SUM] + delta_t;
          
          if (delta_t < mon_period[RX_DYN2_CMM][MON_MIN])       /* Check for minimum found      */
          {
            mon_period[RX_DYN2_CMM][MON_MIN] = delta_t;
          }
          else if (delta_t > mon_period[RX_DYN2_CMM][MON_MAX])  /* Check for maximum found      */
          {
            mon_period[RX_DYN2_CMM][MON_MAX] = delta_t;
          }
        }
      }
    }
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Dyn_Veh (0x388):*/
/*--------------------------------------------------------------------------*/
on message CAN1.Dyn_Veh {
  long delta_t;
  float avg_period_time;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_DYN_VEH][MON_ID])
  {
    MON_ErrorMessage(RX_DYN_VEH, 1);
  }
  else 
  {
    if (mon_period[RX_DYN_VEH][MON_HITS] < (PARAMETERS[RX_DYN_VEH][MON_COUNT] + 2))
    {
      if (this.DLC != PARAMETERS[RX_DYN_VEH][MON_DLC])
      {
        MON_ErrorMessage(RX_DYN_VEH, 2);
      }
      else
      {
        mon_period[RX_DYN_VEH][MON_HITS]++;                    /* Increment receive counter    */

        delta_t = this.TIME - mon_period[RX_DYN_VEH][MON_LAST];/* Calculate period time        */
        mon_period[RX_DYN_VEH][MON_LAST] = this.TIME;          /* Store last time              */
            
        if (mon_period[RX_DYN_VEH][MON_HITS] > 2)              /* Skip first measurement!      */
        {
          mon_period[RX_DYN_VEH][MON_SUM] = mon_period[RX_DYN_VEH][MON_SUM] + delta_t;
          
          if (delta_t < mon_period[RX_DYN_VEH][MON_MIN])       /* Check for minimum found      */
          {
            mon_period[RX_DYN_VEH][MON_MIN] = delta_t;
          }
          else if (delta_t > mon_period[RX_DYN_VEH][MON_MAX])  /* Check for maximum found      */
          {
            mon_period[RX_DYN_VEH][MON_MAX] = delta_t;
          }
        }
      }
    }
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Dat_CMM (0x488):*/
/*--------------------------------------------------------------------------*/
on message CAN1.Dat_CMM {
  long delta_t;
  float avg_period_time;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_DAT_CMM][MON_ID])
  {
    MON_ErrorMessage(RX_DAT_CMM, 1);
  }
  else 
  {
    if (mon_period[RX_DAT_CMM][MON_HITS] < (PARAMETERS[RX_DAT_CMM][MON_COUNT] + 2))
    {
      if (this.DLC != PARAMETERS[RX_DAT_CMM][MON_DLC])
      {
        MON_ErrorMessage(RX_DAT_CMM, 2);
      }
      else
      {
        mon_period[RX_DAT_CMM][MON_HITS]++;                     /* Increment receive counter    */

        delta_t = this.TIME - mon_period[RX_DAT_CMM][MON_LAST]; /* Calculate period time        */
        mon_period[RX_DAT_CMM][MON_LAST] = this.TIME;           /* Store last time              */
            
        if (mon_period[RX_DAT_CMM][MON_HITS] > 2)               /* Skip first measurement!      */
        {
          mon_period[RX_DAT_CMM][MON_SUM] = mon_period[RX_DAT_CMM][MON_SUM] + delta_t;
          
          if (delta_t < mon_period[RX_DAT_CMM][MON_MIN])        /* Check for minimum found      */
          {
            mon_period[RX_DAT_CMM][MON_MIN] = delta_t;
          }
          else if (delta_t > mon_period[RX_DAT_CMM][MON_MAX])   /* Check for maximum found      */
          {
            mon_period[RX_DAT_CMM][MON_MAX] = delta_t;
          }
        }
      }
    }
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Supv_CMM (0x788):*/
/*--------------------------------------------------------------------------*/
on message CAN1.Supv_CMM {
  long delta_t;
  float avg_period_time;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.ID != PARAMETERS[RX_SUPV_CMM][MON_ID])
  {
    MON_ErrorMessage(RX_SUPV_CMM, 1);
  }
  else 
  {
    if (mon_period[RX_SUPV_CMM][MON_HITS] < (PARAMETERS[RX_SUPV_CMM][MON_COUNT] + 2))
    {
      if (this.DLC != PARAMETERS[RX_SUPV_CMM][MON_DLC])
      {
        MON_ErrorMessage(RX_SUPV_CMM, 2);
      }
      else
      {
        mon_period[RX_SUPV_CMM][MON_HITS]++;                    /* Increment receive counter    */

        delta_t = this.TIME - mon_period[RX_SUPV_CMM][MON_LAST];/* Calculate period time        */
        mon_period[RX_SUPV_CMM][MON_LAST] = this.TIME;          /* Store last time              */
            
        if (mon_period[RX_SUPV_CMM][MON_HITS] > 2)              /* Skip first measurement!      */
        {
          mon_period[RX_SUPV_CMM][MON_SUM] = mon_period[RX_SUPV_CMM][MON_SUM] + delta_t;
          
          if (delta_t < mon_period[RX_SUPV_CMM][MON_MIN])       /* Check for minimum found      */
          {
            mon_period[RX_SUPV_CMM][MON_MIN] = delta_t;
          }
          else if (delta_t > mon_period[RX_SUPV_CMM][MON_MAX])  /* Check for maximum found      */
          {
            mon_period[RX_SUPV_CMM][MON_MAX] = delta_t;
          }
        }
      }
    }
  }
}
/*@@end*/

/*@@timer:Absent_Timer:*/
//  /*@@msg:CAN2.CanDB_V63_v1p1::Tram_IdConfig (0x0):*/
//  /*--------------------------------------------------------------------------*/
//  on message CAN2.Tram_IdConfig
//  {
//  BYTE i;
//    if (this.dir==RX)
//    {
//      if ((this.byte(0)>>5) == TRAM_CONFIGID)
//      { /* GetConfigId received */
//        TRAM_CONFIG=this;
//        ID_Cde    = 256*TRAM_CONFIG.byte(1)+TRAM_CONFIG.byte(2);
//        ID_Status = 256*TRAM_CONFIG.byte(3)+TRAM_CONFIG.byte(4);
//        write("");
//        write("GetConfigId ID commands = 0x%lx",ID_Cde);
//        write("            ID status   = 0x%lx",ID_Status);
//        if (stTRAM_ConfigID == 0x01)                          /* Reading req. by state machine 1  */
//        {
//          stTRAM_ConfigID = 0x02;                             /* Variables ID_Cde and ID_Status   */
//                                                              /* contain new values.              */
//        }
//      }
//      else if ((this.byte(0)>>5) == TRAM_CONFIGTRAM)
//      { /* GetConfigTram received */
//        if (((this.byte(0) >>3)& 0x03) == 1)
//        {
//          /* Copy data from reply (1/3) */ 
//          write("");
//          write("Reading script configuration...");
//          write("Script n°% ld (1/3)",this.byte(0)&0x07);
//          ScriptID      = (this.byte(1) << 8) +this.byte(2);
//          ScriptMaskID  = (this.byte(3) << 8) +this.byte(4);
//          ScriptRate    = this.byte(5);
//          ScriptData[0] = this.byte(6);
//          ScriptMask[0] = this.byte(7);
//        }
//        else if (((this.byte(0)>>3) & 0x03) == 2)
//        {
//          /* Copy data from reply (2/3) */ 
//          write("Script n°% ld (2/3)",this.byte(0)&0x07);
//          for(i=1; i<8; i++) ScriptData[i] = this.byte(i);
//        }
//        else if (((this.byte(0) >>3)& 0x03) == 3)
//        {
//          /* Copy data from reply (3/3) */ 
//          for(i=1; i<8; i++) ScriptMask[i] = this.byte(i);
//  
//          write("Script n° %ld (3/3)",this.byte(0)&0x07);
//          write("ID=0x%03lx MaskID=0x%03lx Rate=%ld",ScriptID,ScriptMaskID,ScriptRate);
//          write("Data %02lx %02lx %02lx %02lx %02lx %02lx %02lx %02lx ",ScriptData[0],ScriptData[1],ScriptData[2],ScriptData[3],ScriptData[4],ScriptData[5],ScriptData[6],ScriptData[7]);
//          write("Mask %02lx %02lx %02lx %02lx %02lx %02lx %02lx %02lx ",ScriptMask[0],ScriptMask[1],ScriptMask[2],ScriptMask[3],ScriptMask[4],ScriptMask[5],ScriptMask[6],ScriptMask[7]);
//  
//          if (stTRAM_Script == 0x01)                          /* Reading req. by state machine 2  */
//          {
//            stTRAM_Script = 0x02;                             /* Update on script parameters      */
//          }
//        }
//        else
//        {
//          write("Overflow in GetConfigTram ???");
//        }
//      }
//      else if ((this.byte(0)>>5) == TRAM_GETVERSION)
//      { /* GetVersion received */
//        write("Version Traminator: %d.%02d %02d/%02d/%02d",this.byte(1),this.byte(2),this.byte(3),this.byte(4),this.byte(5));
//      }
//      else
//      {
//        write("Unknown reply ???");
//      }
//   }
//  }
//  /*@@end*/

/*------------------------------------------------------------------------------------------------*/
/*================================================================================================*/
/* Process send message */
/*================================================================================================*/

/*================================================================================================*/
on timer Absent_Timer
{
  write("CAN 1 is again active.");
  sendestopp = 0;                                               /* Senden wieder zulassen */ 
}
/*@@end*/

/*@@timer:timer_mon500ms:*/
/*================================================================================================*/
on timer timer_mon500ms {
  int i;
  float avg_period_time;

  setTimer(timer_mon500ms,500);                                 /* Set timer again.             */


  /* Array construction: mon_period[x][0] = number of message hits                  */
  /*                                  [1] = last time the message was received      */
  /*                                  [2] = sum of period time                      */
  /*                                  [3] = minimum period time                     */
  /*                                  [4] = maximum period time                     */
  /*                                  [5] = Marker request for displaying results   */
  for (i = 0 ; i < rx_msg_nr_max ; i++)
  {
    if (   (mon_period[i][MON_HITS] >= (PARAMETERS[i][MON_COUNT] + 2))
        && (mon_period[i][MON_HITS] <  0x7FFFFFFF)
        && (mon_period[i][MON_DISP] == 0x00000000))
    {
      mon_period[i][MON_DISP] = 0x00000001;                     /* Set marker for displaying    */
    }
    if (mon_period[i][MON_DISP] == 0x00000001)
    {
      mon_period[i][MON_DISP] = 0x00000002;                     /* Stop displaying              */
      if (PARAMETERS[i][MON_PERIOD])                            /* Check if allowed for display */
      {
        write ("");
        if (mon_period[i][MON_HITS] == 0x00000000)
        {
          write ("Message %s not received!", rx_msg_name[i]);
        }
        else if (mon_period[i][MON_HITS] == 0x7FFFFFFF)
        {
          write ("Sorry no measurement startet yet.");
        }
        else
        {
          avg_period_time =   (float)mon_period[i][MON_SUM]
                            / ((float)mon_period[i][MON_HITS] - 2);
          write ("%s Average Period [ms] %f", rx_msg_name[i], (avg_period_time / 100));
          write ("%s Minimum Period [ms] %f", rx_msg_name[i], ((float)mon_period[i][MON_MIN] / 100));
          write ("%s Maximum Period [ms] %f", rx_msg_name[i], ((float)mon_period[i][MON_MAX] / 100));
          write ("");
          write ("Message %s %ld times received.", rx_msg_name[i], (mon_period[i][MON_HITS] - 2));
        }
      }
    } 
  }
}
/*@@end*/

/*@@timer:timer10ms:*/
/*================================================================================================*/
on timer timer10ms {

  setTimer(timer10ms,10);                                     /* Timer gleich neu starten */

  if (data[BVMPAactive_Nr])
  {  
    /************************************************************************************************/
    /* Dyn2_V2_BV ID 3C9 : Signals */
    /************************************************************************************************/

    Dyn2_V2_BV.P291_Com_trqMaxConv          = data[P291_Nr];    /* Maximum torque from clutch */
    Dyn2_V2_BV.P293_Com_stGbxEngShOff       = data[P293_Nr];    /* Engine off request from BV */
  
    /* calculate frame counter P230 for Dyn2_V2_BV 3C9: */
    if (data[Sim_counter_hang_3C9_Nr] == 0)                  /* BV simulation of counter is hanging */
    {
      proc_counter_3C9 = (proc_counter_3C9 + 1) & 0x0F; 
    }
    else
    {
      proc_counter_3C9 = (proc_counter_3C9 + ((data[Sim_counter_hang_3C9_Nr] -1) & 0x0f)) & 0x0F; 
    }

    Dyn2_V2_BV.P230_Com_ctGbxCnt2 = proc_counter_3C9;     /* Process counter */

    /* calculate checksum P340 for Dyn2_V2_BV 3C9: */
    ChkSum_3C9 = 0;
    if (data[Sim_chksum_fault_3C9_Nr] == 0)                         /* ChkSum faulty simulation */
    {
      /* Mod16 addition of P291 */
      ChkSum_3C9 = (data[P291_Nr] & 0x0F) + ((data[P291_Nr] & 0xF0) >> 0x04);
      ChkSum_3C9 = (ChkSum_3C9 & 0x0F);
      /* Mod16 addition of P__Rapport_cible */
      ChkSum_3C9 += (data[P__Rapport_cible_Nr] & 0x0F);
      ChkSum_3C9 = (ChkSum_3C9 & 0x0F);
      /* Mod16 addition of Process counter */
      ChkSum_3C9 += ( proc_counter_3C9 & 0x0F );
      ChkSum_3C9 = (ChkSum_3C9 & 0x0F);   
      /* Mod16 addition of P93 */
      ChkSum_3C9 += ((data[P293_Nr] << 1) & 0x0F);
      ChkSum_3C9 = (ChkSum_3C9 & 0x0F);
      /* Mod16 addition of CHKINI - 0x01 */
      ChkSum_3C9 += 0x01;                                 /* ini for Dyn2_V2_BV = 01h */
      ChkSum_3C9 = (ChkSum_3C9 & 0x0F);
      ChkSum_3C9 = (0x0F - ChkSum_3C9);

      Dyn2_V2_BV.P340_Com_xChkSum2 = ChkSum_3C9 ;    /* Checksum from frame 0x3C9 */

      /* send message */
      versende(Dyn2_V2_BV, Dyn2_V2_BV_Nr);
    }
  }

  if (data[ABSactive_Nr])
  {
    /* Erzeuge Message DYN2_FRE 3CD */
    DYN2_FRE.P224_Com_stBrkRaw_1      = data[P224_Nr];    /* Brake pedal switch */
    DYN2_FRE.P225_Com_stBrkRaw_0      = data[P225_Nr];    /* Brake pedal fault */
    DYN2_FRE.P226_Com_stBrkActv       = data[P226_Nr];    /* Braking in action */
    DYN2_FRE.P319_FrmMng_rClthPos     = data[P319_Nr];    /* Clutch pedal position */
    DYN2_FRE.P515_Com_pStSpMstCyl     = data[P515_Nr];    /* TMC pressure */
            
    /* send message */
    versende(DYN2_FRE, DYN2_FRE_Nr);
  }
}
/*@@end*/

/*@@timer:timer100ms:*/
/*================================================================================================*/
on timer timer100ms {

  setTimer(timer100ms,100);                                     /* Timer gleich neu starten */

  /* For electronic state of the ECU Elec_Int frame ID 0x92 */
  Elec_Int.P__Elec_Int_Cntrl_Word          = data[P__Elec_Int_Cntrl_Word_Nr] ;


  /* versende Messages */
  if (ElecInt_Active > 0 && ElecInt_Active <= ElecInt_NrFrames)
  {
    versende(Elec_Int, Elec_Int_Nr);
    ElecInt_Active++;
  }
  else
  {
    ElecInt_Active = 0;                                     /* reset flag for next activation */    
  }

  if (data[BSIactive_Nr])
  {
/*------------------------------------------------------------------------------------------------*/
    /* Update Message DAT_CLIM 50E */
    // DAT_CLIM.P050_Com_stAC                = data[P050_Nr];    /* demand for air conditioning by driver AC-TH */
    DAT_CLIM.P164_Com_stPFltFan           = data[P164_Nr];    /* fan speed binary request by AC Com_stPFltFan */
    DAT_CLIM.P046_Com_rFanClgDes          = data[P046_Nr];    /* fan speed proportional request by AC Com_rFanMinAC */
    DAT_CLIM.P144_Com_bPFltGlw            = data[P144_Nr];    /* Com_stPFltGlw Forcage_Encl_Bougies */
    DAT_CLIM.P189_Com_stEEMIdlDem         = data[P189_Nr];
    DAT_CLIM.P208_Com_nACIdlDem           = data[P208_Nr];
    DAT_CLIM.P209_Com_stACRaw             = data[P209_Nr];
    DAT_CLIM.P210_Com_pwrACDem            = data[P210_Nr];
    DAT_CLIM.P417_Com_stDrvPrsRaw         = data[P417_Nr];    /* STT Driver presence */
    DAT_CLIM.P432_Com_bCmptEngRstrtReqRaw = data[P432_Nr];    /* STT Engine restart requested by sub system HAB */ 
    DAT_CLIM.P433_Com_bCmptEngStopReqRaw  = data[P433_Nr];    /* STT Engine stop authorization by sub system HAB */

  if ((data[CrCtl_Select_Nr] == 1) || (data[CrCtl_Select_Nr] == 6) )  /* None*/
  {
    data[P221_Nr] = 0x00;
    data[P222_Nr] = 0x00;
    data[P220_Nr] = 0x00;
    data[P219_Nr] = 0xFF;
  }

  if (data[CrCtl_Select_Nr] == 3)   /* cc standby */
  {
    data[P221_Nr] = 0x01;
    data[P222_Nr] = 0x00;
    data[P220_Nr] = 0x00;
    data[P219_Nr] = 0xFF;
  }

  if (data[CrCtl_Select_Nr] == 2)  /* cc active */
  {
    data[P221_Nr] = 0x01;
    data[P222_Nr] = 0x00;
    data[P220_Nr] = 0x01;
    data[P219_Nr] = 0xF0;
  }

  if (data[CrCtl_Select_Nr] == 4)  /* sl standby */
  {
    data[P221_Nr] = 0x02;
    data[P222_Nr] = 0x00;
    data[P220_Nr] = 0x00;
    data[P219_Nr] = 0xFF;
  }

  if (data[CrCtl_Select_Nr] == 5)  /* sl active */
  {
    data[P221_Nr] = 0x02;
    data[P222_Nr] = 0x01;
    data[P220_Nr] = 0x00;
    data[P219_Nr] = 0xF0;
  }


  DAT_CLIM.P219_Com_xPrpReqRaw        = data[P219_Nr];
  DAT_CLIM.P220_Com_stPrpMsgRaw       = data[P220_Nr];
  DAT_CLIM.P221_Speed_setPoint_Typ    = data[P221_Nr];
  DAT_CLIM.P222_Typ_PrpCtl_Req        = data[P222_Nr];

  ChkSum_CrcCtl = 0;
  if (data[P232_InVld_Nr] == 0) 
  {
    /*****  Checksum calculation for P232 *****/
    /* For lower nibble  */
    ChkSum_CrcCtl = data[P219_Nr] & 0x01;
    ChkSum_CrcCtl = ChkSum_CrcCtl + ((data[P219_Nr] & 0x02)>> 0x01);
    ChkSum_CrcCtl = ChkSum_CrcCtl + ((data[P219_Nr] & 0x04)>> 0x02);
    ChkSum_CrcCtl = ChkSum_CrcCtl + ((data[P219_Nr] & 0x08)>> 0x03);

    if((ChkSum_CrcCtl == 0x00) || (ChkSum_CrcCtl == 0x02) || (ChkSum_CrcCtl == 0x04))
    {
      P232_ChkSum = 0x00;
    }
    else
    {
      P232_ChkSum = 0x01;
    }

    ChkSum_CrcCtl = 0;
    /* For Higher nibble  */
    ChkSum_CrcCtl = (data[P219_Nr] & 0x10) >> 0x04;
    ChkSum_CrcCtl = ChkSum_CrcCtl + ((data[P219_Nr] & 0x20)>> 0x05);
    ChkSum_CrcCtl = ChkSum_CrcCtl + ((data[P219_Nr] & 0x40)>> 0x06);
    ChkSum_CrcCtl = ChkSum_CrcCtl + ((data[P219_Nr] & 0x80)>> 0x07);

    if((ChkSum_CrcCtl == 0x00) || (ChkSum_CrcCtl == 0x02) || (ChkSum_CrcCtl == 0x04))
    {
      P232_ChkSum |= 0x00;
    }
    else
    {
      P232_ChkSum |= 0x02;
    }

  }
  else
  {
    P232_ChkSum = 0x00;
  }

    data[P232_Nr] = P232_ChkSum ;

    DAT_CLIM.P232_Com_stXVVChkSum       = data[P232_Nr];

    /* P231 process counter for CrcCtl  */
    switch(data[P231_Typ_Cnt_Nr])
    {

      case 0 : /* Old implementation */
        if (data[P231_CntrHang_Nr] == 0) /* CrcCtl simulation of counter is hanging */
        {
           DataCounter_CrCtl = (DataCounter_CrCtl + 1) & 0x0F; 
        }
        else
        {
          DataCounter_CrCtl = 0x00;
        } 
      break ;
        
      case 1 :  /* Send '0' for some count then odd count */
        if(data[P231_Typ_Cnt_Nr] != Old_TypCnt)
        {
          DataCounter_CrCtl = 0x00;
          cnt_zero = 0 ;    
        }

        if (data[P231_CntrHang_Nr] == 0) /* CrcCtl simulation of counter is hanging */
        {
          if(cnt_zero <= data[P231_tx_Zero_Cnt_Nr])       
          {
            DataCounter_CrCtl = 0x00;
            cnt_zero ++ ;
          }
          else
          {
            if((DataCounter_CrCtl == 0x00) || (DataCounter_CrCtl == 0x0F))
            {
              DataCounter_CrCtl = 0x01;
            } 
            else
            {
              DataCounter_CrCtl = (DataCounter_CrCtl + 2) & 0x0F;
            }
          }
        }
      break;

      case 2 :  /* Send odd count */
        if (data[P231_CntrHang_Nr] == 0) /* CrcCtl simulation of counter is hanging */
        { 
          if(data[P231_Typ_Cnt_Nr] != Old_TypCnt)
          {
            DataCounter_CrCtl = 0x00;
            fst_tx2 = 0 ;    
          }
          if(fst_tx2 == 0 )
          {
            DataCounter_CrCtl = 0x00; 
            fst_tx2 = 1 ;
          }
          if(fst_tx2 == 1 )
          {
            DataCounter_CrCtl = 0x01; 
            fst_tx2 = 2 ;
          }

          if(DataCounter_CrCtl == 0x0F)
          {
            DataCounter_CrCtl = 0x01;
          }  
          else
          {
            DataCounter_CrCtl = (DataCounter_CrCtl + 2) & 0x0F;
          }   
        }
      break ;
        
      case 3 :    /* Send odd count */
        if(data[P231_Typ_Cnt_Nr] != Old_TypCnt)
        {
          DataCounter_CrCtl = 0x00;
          fst_tx3 = 0 ;    
        }                 
        if(fst_tx3 == 0 )
        {
          DataCounter_CrCtl = 0x00; 
          fst_tx3 = 1 ;
        }

        if(fst_tx3 == 1 )
        {
          DataCounter_CrCtl = 0x02; 
          fst_tx3 = 2 ;
        }

        if(DataCounter_CrCtl == 0x0E)
        {
          DataCounter_CrCtl = 0x02;
        } 
        else
        {
          DataCounter_CrCtl = (DataCounter_CrCtl + 2) & 0x0F;
        }   
      break;

           
    }// end switch

    Old_TypCnt = data[P231_Typ_Cnt_Nr];

    data[P231_Nr] = DataCounter_CrCtl;

    DAT_CLIM.P231_Com_ctBSIFrm = data[P231_Nr];

    /* versende Messages */
    versende(DAT_CLIM, DAT_CLIM_Nr);


/*------------------------------------------------------------------------------------------------*/
    /* Update Message Dat3_BSI */
    DAT3_BSI.P429_Com_stSOCInfoInvldRaw   = data[P429_Nr];  /* P429_Com_stSOCInfoInvldRaw */
    DAT3_BSI.P435_Com_stUCAPRechCrntRaw   = data[P435_Nr];  /* P435_Com_stUCAPRechCrntRaw  */
    DAT3_BSI.P434_Com_rBattChHiRes        = data[P434_Nr];  /* P434_Com_rBattChHiRes  */
    DAT3_BSI.P438_Com_uBattIntRstnRaw     = data[P438_Nr];  /* P438_Com_uBattIntRstnRaw  */
    DAT3_BSI.P437_Com_uBattOpnCir         = data[P437_Nr];  /* P437_Com_uBattOpnCir  */
    DAT3_BSI.P493_Com_stPrioVoltMin       = data[P493_Nr];  /* P493_Com_stPrioVoltMin  */
    DAT3_BSI.P490_Com_uVoltCtlProdMin     = data[P490_Nr];  /* P490_Com_uVoltCtlProdMin  */
    DAT3_BSI.P494_Com_stPrioVoltMax       = data[P494_Nr];  /* P494_Com_stPrioVoltMax  */
    DAT3_BSI.P491_Com_uVoltCtlProdMax     = data[P491_Nr];  /* P491_Com_uVoltCtlProdMax  */
    DAT3_BSI.P492_Com_uVarProdMax         = data[P492_Nr];  /* P492_Com_uVarProdMax  */

    /* send message */
    versende(DAT3_BSI, DAT3_BSI_Nr);

    
/*------------------------------------------------------------------------------------------------*/
    /* Update Message Dat6_BSI */
    Dat6_BSI.P272_Com_rBattCh         = data[P272_Nr];    /* Percentage of battery charge */ 
    Dat6_BSI.P273_Com_tBatt           = data[P273_Nr];    /* Battery temperature */ 
    Dat6_BSI.P349_EEM_stAltCtlType    = data[P349_Nr];    /* Alternator control Type */
    Dat6_BSI.P418_Com_uBattRaw        = data[P418_Nr];    /* BECB battery voltage */
    Dat6_BSI.P419_Com_stSTTActvRaw    = data[P419_Nr];    /* STT state change request */
    Dat6_BSI.P420_Com_stBattCrntMeasRaw = data[P420_Nr];  /* Battery current's measurement caliber */
    Dat6_BSI.P421_Com_xBattCrnt       = data[P421_Nr];    /* Battery current */

    /* send message */
    versende(Dat6_BSI, Dat6_BSI_Nr);

    
/*------------------------------------------------------------------------------------------------*/
    /* Update Message Dat7_BSI */
    DAT7_BSI.P409_Com_stRly3DiagRaw   = data[P409_Nr];    /* R3 relay control diagnosis */ 

    /* send message */
    versende(DAT7_BSI, DAT7_BSI_Nr);

  }

  
/*------------------------------------------------------------------------------------------------*/
  if (data[ABSactive_Nr])
  {
    /* Update message Dat_ABR 50D */
    Dat_ABR.P351_Com_bABSIntvActv     = data[P351_Nr];    /* ABS Intv actv */ 
    Dat_ABR.P415_Com_stABSSTTReqRaw   = data[P415_Nr];    /* brake function for STT need */ 

    /* send message */
    versende(Dat_ABR, Dat_ABR_Nr);
  }

/*------------------------------------------------------------------------------------------------*/

  /* Update message DAT_DIRA 495 */
  DAT_DIRA.P447_Com_bStrgWhlEngRstrtReqRaw = data[P447_Nr]; /* P447_Com_bStrgWhlEngRstrtReqRaw */
  DAT_DIRA.P448_Com_bStrgWhlEngStopReqRaw  = data[P448_Nr]; /* P448_Com_bStrgWhlEngStopReqRaw  */

  /* send message */
  versende(DAT_DIRA, DAT_DIRA_Nr);
  
/*------------------------------------------------------------------------------------------------*/
}
/*@@end*/

/*@@timer:timer20ms:*/
/*================================================================================================*/
on timer timer20ms {

  setTimer(timer20ms,20);                                       /* Timer gleich neu starten */

  if (data[CDSactive_Nr])
  {
    /*--------------------------------------------------------------------------------------------*/    
    /* Create message Dyn_CDS 34D */
    switch (data[P047_Nr])                                  /* ESP torque request status */
    {
      case 0:                                               /* No intervention in torque */
        data_Mode_Reg_CdS = 0;                              /* Set Control Type */
        if (data[TCSStatFault_Nr] == 0)                     /* Fault simulation? */
        {
          data_Cons_Stat_TCS = 0xFA;                        /* Set torque to neutral */
        }
        else
        {
          data_Cons_Stat_TCS = data[P043_Nr];               /* ESP simulation of invalid TCS static torque */
        }
        if (data[TCSDynFault_Nr] == 0)                      /* Fault simulation? */
        {
          data_Cons_Dyn_TCS = 0xFA;                         /* Set torque to neutral */
        }
        else
        {
          data_Cons_Dyn_TCS = data[P044_Nr];                /* ESP simulation of invalid TCS dynamic torque */
        }
        if (data[DCSFault_Nr] == 0)                         /* Fault simulation? */
        {
          data_Cons_DCS = 0x00;                             /* Set torque to neutral */
        }
        else
        {
          data_Cons_DCS = data[P045_Nr];                    /* ESP simulation of invalid DCS torque */
        }
      break;

      case 1:                                               /* TCS (ASR) torque intervention */
        data_Mode_Reg_CdS = 5;
        if (data[TCSStatFault_Nr] == 0)                     /* Fault simulation? */
        {
          data_Cons_Stat_TCS = data[P043_Nr];               /* ESP TCS (ASR) static torque request */
        }
        else
        {
          data_Cons_Stat_TCS = 0xFA;                        /* Fault because of neutral value */
        }
        if (data[TCSDynFault_Nr] == 0)                      /* Fault simulation? */
        {
          data_Cons_Dyn_TCS = data[P044_Nr];                /* ESP TCS (ASR) dynamic torque request */
        }
        else
        {
          data_Cons_Dyn_TCS = 0xFA;                         /* Set torque to neutral */
        }
        if (data[DCSFault_Nr] == 0)                         /* Fault simulation? */
        {
          data_Cons_DCS = data_Cons_Stat_TCS ^ 0xFF;        /* Set ones complement of TCS static torque */
        }
        else
        {
          data_Cons_DCS = data[P045_Nr];                    /* ESP simulation of invalid DCS torque */
        }
      break;
    
      case 2:                                               /* DCS (MSR) torque intervention */
        data_Mode_Reg_CdS = 6;
        if (data[DCSFault_Nr] == 0)                         /* Fault simulation? */
        {
          data_Cons_DCS = data[P045_Nr];                    /* ESP DCS (MSR) torque request */
        }
        else
        {
          data_Cons_DCS = 0;                                /* Fault because of neutral value */
        }
        if (data[TCSStatFault_Nr] == 0)                     /* Fault simulation? */
        {
          data_Cons_Stat_TCS = 0xFA;                        /* Set torque to neutral */
        }
        else
        {
          data_Cons_Stat_TCS = data[P043_Nr];               /* ESP simulation of invalid TCS static torque */
        }
        if (data[TCSDynFault_Nr] == 0)                      /* Fault simulation? */
        {
          data_Cons_Dyn_TCS = data_Cons_DCS ^ 0xFF;         /* Set ones complement of DCS torque */
        }
        else
        {
          data_Cons_Dyn_TCS = data[P044_Nr];                /* ESP simulation of invalid TCS dynamic torque */
        }
      break;
    
      default:                                              /* unzulaessige Betriebsart */
        data_Mode_Reg_CdS  = data[P047_Nr];                 /* ESP torque request status */
        data_Cons_Stat_TCS = data[P043_Nr];                 /* ESP TCS (ASR) static torque request */
        data_Cons_Dyn_TCS  = data[P044_Nr];                 /* ESP TCS (ASR) dynamic torque request */
        data_Cons_DCS      = data_Counter;                  /* ESP message counter */
      break;
    }

    /* Daten in Message kopieren */
    DYN_CDS.P047_Com_stESPIntv      = data_Mode_Reg_CdS;
    DYN_CDS.P147_Com_bESPIntvActv   = data[P147_Nr];        /* ESP TCS (ASR) in regulation */
    DYN_CDS.P043_Com_xTCSStatRaw    = data_Cons_Stat_TCS;
    DYN_CDS.P044_Com_trqTCSRaw      = data_Cons_Dyn_TCS;
    DYN_CDS.P045_Com_trqDCSRaw      = data_Cons_DCS;
    DYN_CDS.P157_Com_ctESP          = data_Counter;

    if (data[CounterFault_Nr] == 0)                         /* ESP simulation of counter is hanging */
    {
      /* No fault simulation, so count up and do overrun when 0x10 is get. */
      data_Counter = (data_Counter + 1) & 0x0F;             /* Increment of ESP message counter */
    }  

    /* versende Messages */
    versende(DYN_CDS, DYN_CDS_Nr);

    /*--------------------------------------------------------------------------------------------*/    
    /* For the Frame Dyn_EasyMove 3AD */

    Dyn_EasyMove.P299_Com_bCrCtlInhib  = data [P299_Nr] ;
    Dyn_EasyMove.P337_Com_stPrkBrk     = data [P337_Nr] ;

    /* send messager */
    versende(Dyn_EasyMove, Dyn_EasyMove_Nr);
  
    /*--------------------------------------------------------------------------------------------*/    

    /* create message Dyn4_FRE 30D */
    Dyn4_FRE.P263_VehV_VPsvValWhlFrtL    = data[P263_Nr];        /* front left wheel velocity  */
    Dyn4_FRE.P264_VehV_VPsvValWhlFrtR    = data[P264_Nr];        /* front right wheel velocity  */
   
    /* Transmit the Message */
    versende(Dyn4_FRE, Dyn4_FRE_Nr); 
    /*--------------------------------------------------------------------------------------------*/    
  }
  
  /* create message Dyn_STT_BV 329 */
  if (data[BVMPAactive_Nr])
  {
    Dyn_STT_BV.P441_Com_bGbxAuthRstrtRaw    = data[P441_Nr];  /* P441_Com_bGbxAuthRstrtRaw */
    Dyn_STT_BV.P442_Com_bGbxAuthStopRaw     = data[P442_Nr];  /* P442_Com_bGbxAuthStopRaw  */
    Dyn_STT_BV.P443_Com_bGbxRstrtReq        = data[P443_Nr];  /* P443_Com_bGbxRstrtReq     */
    Dyn_STT_BV.P444_Com_bGbxSysFaultRaw     = data[P444_Nr];  /* P444_Com_bGbxSysFaultRaw  */
    
    /* calculate process counter P230 for Dyn_STT_BV 329: */
    if (data[Sim_counter_hang_329_Nr] == 0)               /* STT simulation of counter is hanging */
    {
      proc_counter_329 = (proc_counter_329 + 1) & 0x0F; 
    }
    else
    {
      proc_counter_329 = (proc_counter_329 + ((data[Sim_counter_hang_329_Nr] - 1) & 0x0f)) & 0x0F; 
    }  
    Dyn_STT_BV.P230_Com_ctGbxCnt3 = proc_counter_329;     /* process counter */


    /* calculate checksum P340 for Dyn_STT_BV 329: */
    ChkSum_329 = 0;
    ChkSum_329_Tmp = 0;
   
    /* Checksum is calculated so that the Mod16 addition of all the nibbles of the frame including
       the checksum is 0x0F */

    if (data[Sim_chksum_fault_329_Nr] == 0)                         /* ChkSum not faulty */
    {
      /* P230 */
      ChkSum_329 += (proc_counter_329 & 0x0F);
      ChkSum_329 = (ChkSum_329 & 0x0F);
      /* P441, 444, 443, 442 */
      ChkSum_329_Tmp = data[P441_Nr] + (data[P444_Nr] << 0x01) + (data[P443_Nr] << 0x02) + (data[P442_Nr] << 0x03);
      ChkSum_329 += ChkSum_329_Tmp;
      ChkSum_329 = (ChkSum_329 & 0x0F);
      /* Checksum INI : 0x02 */
      ChkSum_329 = ChkSum_329 + 0x02 ;       /* ini for Dyn_STT_BV = 02h */
      ChkSum_329 = (ChkSum_329 & 0x0F);

      ChkSum_329 = (0x0F - ChkSum_329);
    }
    Dyn_STT_BV.P340_Com_xChkSum3 = ChkSum_329 ;         /* Checksum from STT BV */

    /* send message */
    versende(Dyn_STT_BV, Dyn_STT_BV_Nr); 
  }
  /*--------------------------------------------------------------------------------------------*/    
  
  
}
/*@@end*/

/*@@timer:timer40ms:*/
/*================================================================================================*/
on timer timer40ms {
  
  setTimer(timer40ms,40);                                       /* Timer gleich neu starten */

  if (data[ABSactive_Nr])
  {
    /* ABS sendet Geschwindigkeit */
    DYN_ABR.P010_Com_v    = data[P010_Nr];            /* ABS velocity     */
    DYN_ABR.P052_Com_aLng = data[P052_Nr];            /* ABS acceleration */
    DYN_ABR.P688_Com_bAuthHllAsstStop = data[P688_Nr];/* Hill assist stop authorization for STT */
    
    
    /* versende Message */
    versende(DYN_ABR, DYN_ABR_Nr);
  
//  Dyn4_FRE belongs to 20ms timer!?  pf
//    /* Dyn4_FRE info */
//    Dyn4_FRE.P263_VehV_VPsvValWhlFrtL    = data[P263_Nr];        /* front left wheel velocity  */
//    Dyn4_FRE.P264_VehV_VPsvValWhlFrtR    = data[P264_Nr];        /* front right wheel velocity  */
//    
//    /* Transmit the Message */
//    versende(Dyn4_FRE, Dyn4_FRE_Nr); 
  
    /* ABS sendet Geschwindigkeit */
    Vroues_ABR.P330_VehV_vWhlRrL    = data[P330_Nr];        /* rear left wheel velocity  */
    Vroues_ABR.P331_VehV_vWhlRrR    = data[P331_Nr];        /* rear right wheel velocity  */
    Vroues_ABR.P354_VehV_nWhlAvrg   = data[P354_Nr];        /* average wheel speed */
    
    /* versende Message */
    versende(Vroues_ABR, Vroues_ABR_Nr);                          
  }
  else
  {
    if (data[BVMPAactive_Nr])
    {
      /* BVA sendet Geschwindigkeit */
//      DYNV_BV.P059_vBVA = data[P059_Nr];        /* BVA velocity     */
//      DYNV_BV.P061_sBVA += data[P059_Nr]/900;   /* BVA odometer     */
//      DYNV_BV.P065_aBVA = data[P065_Nr];        /* BVA acceleration */
      
      /* versende Message */
//      versende(DYNV_BV, DYNV_BV_Nr);
    }
  }
}
/*@@end*/

/*@@timer:timer1000ms:*/
/*================================================================================================*/
on timer timer1000ms {

  setTimer(timer1000ms,1000);                                   /* Timer gleich neu starten     */
  
   if (data[BSIactive_Nr])
  {
    /*--------------------------------------------------------------------------------------------*/    
    /* Create message CONTEXTE1_5B2 for AEE2010 */
    CONTXT1.P100_Com_stAddPmpDef        = data[P100_Nr];      /* FrmMng_stAddPmpDef Status of additive */
    CONTXT1.P146_Com_tEnvT              = data[P146_Nr];      /* Environment air temperature */
    CONTXT1.P__Com_stEOBD               = data[P__Com_stEOBD_Nr]; /* State of EOBD info from BSI */
    
    /* send message */
    versende(CONTXT1, CONTXT1_Nr);

    
    /* Create message CONTEXTE1 for AEE2007 */

    /*   ...   */    
    /*   ...   */    

    /*--------------------------------------------------------------------------------------------*/    
    /* Create message Dat4_BSI_AEE2007 */
    // DAT4_BSI.P255_Com_tiSec             = data[P255_Nr];
    // DAT4_BSI.P256_Com_tiDay             = data[P256_Nr];
    // DAT4_BSI.P257_Com_tiYr              = data[P257_Nr];

    /* Create message Dat4_BSI_AEE2010 */
    DAT4_BSI.P015_Com_lTotDst             = data[P015_Nr];
    DAT4_BSI.P325_Com_tiEngOff            = data[P325_Nr];    /* P325_Com_tiEngOff */
    DAT4_BSI.P326_Com_ctTmrRst            = data[P326_Nr];


    /* versende Messages */
    versende(DAT4_BSI, DAT4_BSI_Nr);
    /*--------------------------------------------------------------------------------------------*/    
    
  }
}
/*@@end*/

/*@@timer:timer50ms:*/
/*================================================================================================*/
on timer timer50ms {

  dword var_key;

  setTimer(timer50ms,50);                                   /* Timer gleich neu starten */

  var_key = keypressed();                                   /* Read in from keyboard            */

  if (data[BSIactive_Nr])
  {
    //    switch (var_key)
    //    {
    //      case 'u' :
    //        data[P041_Nr] = 0x01; break;                        /* Command cruise control           */
    //                                                            /* increment or acceleration        */
    //      case 'i' :
    //        data[P041_Nr] = 0x02; break;                        /* Command cruise control           */
    //                                                            /* decrement or deceleration        */
    //      case 'n' :
    //        data[P041_Nr] = 0x03; break;                        /* Command cruise control switch off*/
    //
    //      default :
    //        data[P041_Nr] = 0x00; break;                        /* No command cruise control        */
    //    }

    /*--------------------------------------------------------------------------------------------*/    
    /* Erzeuge Message Dat_BSI 412 */
    DAT_BSI.P013_MainBrake          = data[P013_Nr];
    DAT_BSI.P040_MainBrakeFault     = data[P040_Nr];
    DAT_BSI.P104_Dspl_stAOHt        = data[P104_Nr];
    DAT_BSI.P086_Com_stFlLvlDia     = data[P086_Nr];        /* FrmMng_stFlMinRls Minimum fuel level is valid.*/
    DAT_BSI.P012_Com_bFlMin         = data[P012_Nr];        /* FrmMng_stFlMin Minimum fuel level is detected. */
    DAT_BSI.P298_Req_RTE_Ena        = data[P298_Nr];
    DAT_BSI.P103_Com_bRevGear       = data[P103_Nr];
    DAT_BSI.P277_Com_bOilLvlDem     = data[P277_Nr];        /* Oil level measurement demand */ 
    DAT_BSI.P328_Com_stEHRPmp       = data[P328_Nr];        /* Water pump status RTE V63 */ 

    /*--------------------------------------------------------------------------------------------*/    
    /* Messages from Dat_BSI1 432 */
    DAT_BSI1.P214_Com_stMnWkUp          = data[P214_Nr];
    DAT_BSI1.P216_Com_bSiaWkUp          = data[P216_Nr];
    DAT_BSI1.P249_Com_stEngStopReq      = data[P249_Nr];
    //DAT_BSI1.P251_Com_stScndStrtReq     = data[P251_Nr];
    DAT_BSI1.P253_Com_bEngPrepReq       = data[P253_Nr];
    DAT_BSI1.P267_Exh_volRefl           = data[P267_Nr];
    DAT_BSI1.P274_Exh_ctRefl            = data[P274_Nr];
    DAT_BSI1.P276_Com_bOilWkUp          = data[P276_Nr];
    DAT_BSI1.P402_Com_stStaDemActv      = data[P402_Nr];
    DAT_BSI1.P403_Com_stStaReq          = data[P403_Nr];
    DAT_BSI1.P350_Com_bPstVtln          = data[P350_Nr]; 
    DAT_BSI1.P367_Com_stCtxJDDRaw       = data[P367_Nr]; 
    DAT_BSI1.P368_Com_stMnSEVRaw        = data[P368_Nr]; 
    DAT_BSI1.P369_Com_stElecNetRaw      = data[P369_Nr]; 
    DAT_BSI1.P439_Com_bUCAPSWkUpReqRaw  = data[P439_Nr];   

    /* send messages */
    versende(DAT_BSI, DAT_BSI_Nr);
    versende(DAT_BSI1, DAT_BSI1_Nr);
  }

  /*----------------------------------------------------------------------------------------------*/
  if (data[Airbagactive_Nr])
  {
    /* create message Etat_Crash 4C8 */
    CRASH.Reserved_1                = 0xFF;
    CRASH.P223_CrashInfo            = data[P223_Nr];
    CRASH.Reserved_2                = 0xFF;

    /* send message */
    versende(CRASH, CRASH_Nr);
  }
}
/*@@end*/

/*@@caplFunc:SetDataMaskZero():*/
//  /*================================================================================================*/
//  /*@@timer:timer250ms:*/
//  /*--------------------------------------------------------------------------*/
//  on timer timer250ms {
//  BYTE i, res;
//  
//    setTimer(timer250ms,250);                                 /* Set next timer period. */
//    
//    /* State machines for processing Traminator control */
//    /* 1. Check of identifier configuration in process ... */
//    if (stTRAM_ConfigID != 0x00)
//    {
//      if (stTRAM_ConfigID == 0x02)
//      /* Reply from Traminator has been received. */
//      {
//        if (   (ID_Cde    != TRAM_ID_CDE)
//            || (ID_Status != TRAM_ID_STATUS) )
//        {
//          /* Set identifier configuration to default. */
//          ID_Cde    = TRAM_ID_CDE;
//          ID_Status = TRAM_ID_STATUS;
//  
//          TRAM_CONFIG.dlc=5;
//          TRAM_CONFIG.byte(0) = TRAM_CONFIGID<<5;
//          TRAM_CONFIG.byte(1) = ID_Cde>>8;
//          TRAM_CONFIG.byte(2) = ID_Cde;
//          TRAM_CONFIG.byte(3) = ID_Status>>8;
//          TRAM_CONFIG.byte(4) = ID_Status;
//          output(TRAM_CONFIG);
//  
//          write ("");
//          write ("Configuration changed to:");
//          /* GetConfigId */
//          TRAM_CONFIG.dlc     = 1;
//          TRAM_CONFIG.byte(0) = TRAM_GETCONFIGID<<5;
//          output(TRAM_CONFIG);
//        }
//        stTRAM_ConfigID = 0x00;                               /* Reset state machine 1            */   
//      }
//    }
//    /* 2. Check of script configuration in process ... */
//    if (stTRAM_Script != 0x00)
//    {
//      if (stTRAM_Script == 0x01)
//      {
//        /* Waiting and monitoring of Traminator script configuration reading... */
//        ctTRAM_WaitOnReply++;
//        if (ctTRAM_WaitOnReply >= TRAM_MAXDLYREPLY)
//        {
//          /* Force writing of script configuration */
//          stTRAM_Script = 0x02;
//          ScriptID = 0x7FFFFFFF;                              /* Set ridiculous ID                */
//          write ("");
//          write ("Timeout reading script configuration ???");
//          write ("");
//        }
//      }
//      if (stTRAM_Script == 0x02)
//      /* Reply from Traminator has been received. */
//      {
//        res = 0;                                              /* Initialise fault marker          */
//        for(i=0; i<8; i++)                                    /* Check for differences in ...     */
//        {
//          if (ScriptData[i] != ScriptDataNew[i])              /* 1. data and                      */
//            res++;
//          if (ScriptMask[i] != ScriptMaskNew[i])              /* 2. mask                          */
//            res++;
//        }
//  
//        if (   (ScriptID     != ScriptIDNew)
//            || (ScriptMaskID != ScriptMaskIDNew)
//            || (ScriptRate   != ScriptRateNew)
//            || (res != 0))
//        {
//          /* Set new script configuration. */
//          TRAM_CONFIG.dlc=8;
//          TRAM_CONFIG.byte(0) = (TRAM_CONFIGTRAM<<5) + (1<<3) + ScriptNo;
//          TRAM_CONFIG.byte(1) = ScriptIDNew>>8;               /* IdPert high-byte                 */
//          TRAM_CONFIG.byte(2) = ScriptIDNew;                  /* IdPert low-byte                  */
//          TRAM_CONFIG.byte(3) = ScriptMaskIDNew>>8;           /* MaskIdPert high-byte             */
//          TRAM_CONFIG.byte(4) = ScriptMaskIDNew;              /* MaskIdPert low-byte              */
//          TRAM_CONFIG.byte(5) = ScriptRateNew;                /* Rate 1/n                         */
//          TRAM_CONFIG.byte(6) = ScriptDataNew[0];             /* Data 0 value to compare          */
//          TRAM_CONFIG.byte(7) = ScriptMaskNew[0];             /* Mask on data 0 value to compare  */
//          output(TRAM_CONFIG);
//  
//          TRAM_CONFIG.byte(0) = (TRAM_CONFIGTRAM<<5) + (2<<3) + ScriptNo;
//          TRAM_CONFIG.byte(1) = ScriptDataNew[1];             /* Data 1 value to compare          */
//          TRAM_CONFIG.byte(2) = ScriptDataNew[2];             /* Data 2 value to compare          */
//          TRAM_CONFIG.byte(3) = ScriptDataNew[3];             /* Data 3 value to compare          */
//          TRAM_CONFIG.byte(4) = ScriptDataNew[4];             /* Data 4 value to compare          */
//          TRAM_CONFIG.byte(5) = ScriptDataNew[5];             /* Data 5 value to compare          */
//          TRAM_CONFIG.byte(6) = ScriptDataNew[6];             /* Data 6 value to compare          */
//          TRAM_CONFIG.byte(7) = ScriptDataNew[7];             /* Data 7 value to compare          */
//          output(TRAM_CONFIG);
//  
//          TRAM_CONFIG.byte(0) = (TRAM_CONFIGTRAM<<5) + (3<<3) + ScriptNo;
//          TRAM_CONFIG.byte(1) = ScriptMaskNew[1];             /* Mask on data 1 value to compare  */
//          TRAM_CONFIG.byte(2) = ScriptMaskNew[2];             /* Mask on data 2 value to compare  */
//          TRAM_CONFIG.byte(3) = ScriptMaskNew[3];             /* Mask on data 3 value to compare  */
//          TRAM_CONFIG.byte(4) = ScriptMaskNew[4];             /* Mask on data 4 value to compare  */
//          TRAM_CONFIG.byte(5) = ScriptMaskNew[5];             /* Mask on data 5 value to compare  */
//          TRAM_CONFIG.byte(6) = ScriptMaskNew[6];             /* Mask on data 6 value to compare  */
//          TRAM_CONFIG.byte(7) = ScriptMaskNew[7];             /* Mask on data 7 value to compare  */
//          output(TRAM_CONFIG);
//          write ("");
//          write ("Script n°% ld configuration changed to:", ScriptNo);
//          write("ID=0x%03lx MaskID=0x%03lx Rate=%ld",ScriptIDNew,ScriptMaskIDNew,ScriptRateNew);
//          write("Data %02lx %02lx %02lx %02lx %02lx %02lx %02lx %02lx "
//                , ScriptDataNew[0], ScriptDataNew[1], ScriptDataNew[2], ScriptDataNew[3]
//                , ScriptDataNew[4], ScriptDataNew[5], ScriptDataNew[6], ScriptDataNew[7]);
//          write("Mask %02lx %02lx %02lx %02lx %02lx %02lx %02lx %02lx "
//                , ScriptMaskNew[0] ,ScriptMaskNew[1], ScriptMaskNew[2], ScriptMaskNew[3]
//                , ScriptMaskNew[4] ,ScriptMaskNew[5], ScriptMaskNew[6], ScriptMaskNew[7]);
//  
//        }
//        stTRAM_Script = 0x03;                                 /* Request to perform remote mode   */
//      }
//      else
//      {
//        if (stTRAM_Script == 0x03)
//        {
//          TRAM_CDE.dlc     = 4;
//          TRAM_CDE.ID      = ID_Cde;
//          TRAM_CDE.byte(0) = TRAM_CHANGEMODE<<3;
//          if (ScriptMaxCount == 0x0000)
//          {
//            TRAM_CDE.byte(1) = (0x00 << 4) + ScriptNo;        /* Start script mode for infinity   */
//          }
//          else
//          {
//            TRAM_CDE.byte(1) = (0x0F << 4) + ScriptNo;        /* Start script mode with MaxCount  */
//          }
//          TRAM_CDE.byte(2) = (ScriptMaxCount & 0xFF);         /* MaxCount low-byte                */
//          TRAM_CDE.byte(3) = 0x00;
//          output(TRAM_CDE);                                   /* Perform remote mode              */
//  
//          stTRAM_Script = 0x00;                               /* Reset state machine 2            */   
//        }
//      }
//    }
//  }
//  /*@@end*/
/*================================================================================================*/

/*--------------------------------------------------------------------------*/
void SetDataMaskZero (void)
{
BYTE i;
  for(i=0; i<8; i++)
  {
    ScriptDataNew[i] = 0x00;                                /* Set new data to zero             */
    ScriptMaskNew[i] = 0x00;                                /* Set new mask to zero             */
  }
}
/*@@end*/

/*@@caplFunc:SetData(byte,byte,byte,byte,byte,byte,byte,byte):*/
/*--------------------------------------------------------------------------*/
void SetData (BYTE SetScriptD0,
              BYTE SetScriptD1,
              BYTE SetScriptD2,
              BYTE SetScriptD3,
              BYTE SetScriptD4,
              BYTE SetScriptD5,
              BYTE SetScriptD6,
              BYTE SetScriptD7)
{
  ScriptDataNew[0] = SetScriptD0;
  ScriptDataNew[1] = SetScriptD1;
  ScriptDataNew[2] = SetScriptD2;
  ScriptDataNew[3] = SetScriptD3;
  ScriptDataNew[4] = SetScriptD4;
  ScriptDataNew[5] = SetScriptD5;
  ScriptDataNew[6] = SetScriptD6;
  ScriptDataNew[7] = SetScriptD7;
}
/*@@end*/

/*@@caplFunc:SetMask(byte,byte,byte,byte,byte,byte,byte,byte):*/
/*--------------------------------------------------------------------------*/
void SetMask (BYTE SetScriptM0,
              BYTE SetScriptM1,
              BYTE SetScriptM2,
              BYTE SetScriptM3,
              BYTE SetScriptM4,
              BYTE SetScriptM5,
              BYTE SetScriptM6,
              BYTE SetScriptM7)
{
  ScriptMaskNew[0] = SetScriptM0;
  ScriptMaskNew[1] = SetScriptM1;
  ScriptMaskNew[2] = SetScriptM2;
  ScriptMaskNew[3] = SetScriptM3;
  ScriptMaskNew[4] = SetScriptM4;
  ScriptMaskNew[5] = SetScriptM5;
  ScriptMaskNew[6] = SetScriptM6;
  ScriptMaskNew[7] = SetScriptM7;
}
/*@@end*/

/*@@key:0x0011:*/
//  /*@@caplFunc:SetScript(byte,word,long,long,byte):*/
//  /*--------------------------------------------------------------------------*/
//  void SetScript (BYTE SetScriptNo,
//                  WORD SetMaxCount,
//                  long SetID,
//                  long SetMaskID,
//                  BYTE SetRate)
//  {
//    ScriptNo = SetScriptNo;                                   /* Set script number to configure.  */
//    ScriptMaxCount = SetMaxCount;                             /* Set the value of MaxCount        */
//  
//    ScriptIDNew         = SetID;                              /* New ID of message to disturb     */
//    ScriptMaskIDNew     = SetMaskID;                          /* New mask on ID of mes. to disturb*/
//    ScriptRateNew       = SetRate;                            /* New perturbation rate [0-255]    */
//    stTRAM_Script       = 0x01;                               /* Wait for reply from Tram.        */
//    ctTRAM_WaitOnReply  = 0x00;                               /* Reset monitoring timer.          */
//  
//    /* Script configuration reading command */
//    TRAM_CONFIG.dlc     = 1;
//    TRAM_CONFIG.byte(0) = (TRAM_GETCONFIGTRAM<<5) + (ScriptNo & 0x07);
//    output(TRAM_CONFIG);
//  }
//  /*@@end*/

//  /*@@key:'1':*/
//  /*--------------------------------------------------------------------------*/
//  on key '1' /* Initialise Traminator */
//  {
//    /* Get version identification of Traminator */
//    TRAM_CONFIG.dlc=1;
//    TRAM_CONFIG.byte(0) = TRAM_GETVERSION<<5;
//    output(TRAM_CONFIG);
//  
//    /* GetConfigId */
//    TRAM_CONFIG.dlc=1;
//    TRAM_CONFIG.byte(0) = TRAM_GETCONFIGID<<5;
//    output(TRAM_CONFIG);
//    stTRAM_ConfigID = 0x01;                                   /* Wait for reply from Tram. */
//    stTRAM_Script = 0x00;                                     /* Reset state machine 2            */   
//  }
//  /*@@end*/

//  /*@@key:'2':*/
//  /*--------------------------------------------------------------------------*/
//  on key '2'  /* BusToGround */
//  {
//    TRAM_CDE.dlc     = 1;
//    TRAM_CDE.ID      = ID_Cde;
//    TRAM_CDE.byte(0) = TRAM_BUSTOGROUND<<3;
//    output(TRAM_CDE);
//    write("Grounding of CANH and CANL");
//  }
//  /*@@end*/
//  
//  /*@@key:'3':*/
//  /*--------------------------------------------------------------------------*/
//  on key '3' /* BusToNormal */
//  {
//    TRAM_CDE.dlc     = 1;
//    TRAM_CDE.ID      = ID_Cde;
//    TRAM_CDE.byte(0) = TRAM_BUSTONORMAL<<3;
//    output(TRAM_CDE);
//    write("Cancelled the grounding of CANH and CANL");
//  }
//  /*@@end*/
//  
//  /*@@key:'4':*/
//  /*--------------------------------------------------------------------------*/
//  on key '4'/* BusIsol */
//  {
//    TRAM_CDE.dlc     = 1;
//    TRAM_CDE.ID      = ID_Cde;
//    TRAM_CDE.byte(0) = TRAM_BUSISOL<<3;
//    output(TRAM_CDE);
//    write("Isolation of ECU to test from CAN");
//  }
//  /*@@end*/
//  
//  /*@@key:'5':*/
//  /*--------------------------------------------------------------------------*/
//  on key '5' /* BusConnect */
//  {
//    TRAM_CDE.dlc     = 1;
//    TRAM_CDE.ID      = ID_Cde;
//    TRAM_CDE.byte(0) = TRAM_BUSCONNECT<<3;
//    output(TRAM_CDE);
//    write("Connected ECU to test to CAN");
//  }
//  /*@@end*/
//  
//  /*@@key:'6':*/
//  /*--------------------------------------------------------------------------*/
//  on key '6'  /* Activate script for red. break propagation delay measuring, Dyn_CMM, ID 0x208    */
//  {
//    SetData (0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00); /* New value of data to compare.    */
//    SetMask (0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00); /* New mask on the data to compare. */
//    /*                                 |                                                          */
//    /*                                 +------------------------ P014 redundant break info        */
//    /*                                                           Byte / Bit Index = Byte 4 : 1    */
//  
//    SetScript (  0x03,        /* ISOL_ACK_2 destruction */    /* Set script number to configure.  */
//                 0x0002,                                      /* Set the value of MaxCount        */
//                 0x0208,                                      /* New ID of message to disturb     */
//                 0x0FFF,                                      /* New mask on ID of mes. to disturb*/
//                 0x02);                                       /* New perturbation rate [0-255]    */
//    write("Starting measurement on redundant break active.");
//    write("(Stop by <9>)");
//  }
//  /*@@end*/
//  
//  /*@@key:'7':*/
//  /*--------------------------------------------------------------------------*/
//  on key '7'  /* Activate script for disturbing Dat_CMM 488 */
//  {
//    /* Explanation of Traminator Scripts */
//    /* 1 = ERR_FRAME    destruction      */
//    /* 2 = ISOL_ACK_9   destruction      */
//    /* 3 = ISOL_ACK_2   destruction      */
//    /* 4 = SCRAMBLE_ACK destruction      */
//  
//    SetDataMaskZero ();                                       /* Set new data and mask to zero.   */
//  
//    SetScript (  0x01,                                        /* Set script number to configure.  */
//                 0x0000,                                      /* Set the value of MaxCount        */
//                 0x0488,                                      /* New ID of message to disturb     */
//                 0x0FFF,                                      /* New mask on ID of mes. to disturb*/
//                 0x01);                                       /* New perturbation rate [0-255]    */
//    write("Disturbing Dat_CMM.");
//    write("(Stop by <9>)");
//  }
//  /*@@end*/
//  
//  /*@@key:'9':*/
//  /*--------------------------------------------------------------------------*/
//  on key '9' /* Cancel script mode and come back to remote mode. */
//  {
//    TRAM_CDE.dlc     = 2;
//    TRAM_CDE.ID      = ID_Cde;
//    TRAM_CDE.byte(0) = TRAM_CHANGEMODE<<3;
//    TRAM_CDE.byte(1) = 0x00;
//    output(TRAM_CDE);
//    write("Script n° %ld is stopped.", ScriptNo);
//  
//    stTRAM_Script = 0x00;                                     /* Reset state machine 2            */   
//  }
//  /*@@end*/


/*--------------------------------------------------------------------------*/
on key 0x11   /*Ctrl_q*/
{
  data[data_sel] += 100;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:0x0001:*/
/*--------------------------------------------------------------------------*/
on key 0x01   /*Ctrl_a*/
{
  data[data_sel] -= 100;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'A':*/
/*--------------------------------------------------------------------------*/
on key 'A'
{
  data[data_sel] -= 10;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'D':*/
/*--------------------------------------------------------------------------*/
on key 'D'
{
  int s, z, i; 

  write("%s",leerzeile);
  write("%s",header);
  write("%s",leerzeile);

  FOR (s=0; s < spalten_max; s++)
  { 
    /* wenn Spalte inaktiv */
    if ((data_tab[s][0] == Unused_Nr) || (data_tab[s][0] == Reserved_Nr))
    { 
      write("Menue %ld not maintained!", s);
      write("%s",unterstr);
    }
    else
    { 
      write("Menue %ld:", s);
      print_spalte(s);
      write("%s",unterstr);
    }
  }
}
/*@@end*/

/*@@key:'p':*/
/*--------------------------------------------------------------------------*/
on key 'p'
{
  /* Stop measuring of period times */

  int i;

  /* Initialise variables for message monitoring */
  /* Array construction: mon_period[x][0] = number of message hits                  */
  /*                                  [1] = last time the message was received      */
  /*                                  [2] = sum of period time                      */
  /*                                  [3] = minimum period time                     */
  /*                                  [4] = maximum period time                     */
  /*                                  [5] = Marker request for displaying results   */
  for (i = 0 ; i < rx_msg_nr_max ; i++)
  {
    mon_period[i][MON_DISP]= 0x00000001;                        /* Set marker for displaying    */
  }
  write ("");
  write ("Period time measurment is stopped at %f [s].",((float)TIMENOW())/100000);
}
/*@@end*/

/*@@key:'P':*/
/*--------------------------------------------------------------------------*/
on key 'P'
{
  /* Start measuring of period times received messages */

  int i;

  /* Initialise variables for message monitoring */
  /* Array construction: mon_period[x][0] = number of message hits                  */
  /*                                  [1] = last time the message was received      */
  /*                                  [2] = sum of period time                      */
  /*                                  [3] = minimum period time                     */
  /*                                  [4] = maximum period time                     */
  /*                                  [5] = Marker request for displaying results   */
  for (i = 0 ; i < rx_msg_nr_max ; i++)
  {
    mon_period[i][MON_LAST]= 0x00000000;                        /* Reset last value to zero     */
    mon_period[i][MON_SUM] = 0x00000000;                        /* Reset sum of period time     */
    mon_period[i][MON_MIN] = 0x7FFFFFFF;                        /* Set to infinity for minimum  */
    mon_period[i][MON_MAX] = 0x00000000;                        /* Reset maximum                */
    mon_period[i][MON_DISP]= 0x00000000;                        /* Reset marker for displaying  */
  }
  for (i = 0 ; i < rx_msg_nr_max ; i++)
  {
    mon_period[i][MON_HITS]= 0x00000000;                        /* Init. counter and start      */
  }
  write ("");
  write ("Period time measurment is started at %f [s].",((float)TIMENOW())/100000);
  write ("Be patient please...");
}
/*@@end*/

/*@@key:'Q':*/
/*--------------------------------------------------------------------------*/
on key 'Q'
{
  data[data_sel]+=10;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'W':*/
/*--------------------------------------------------------------------------*/
on key 'W'
{
  data[data_sel]+=100;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'E':*/
/*--------------------------------------------------------------------------*/
on key 'E'
{
  data[data_sel]+=1000;
  data[data_sel] = begrenze (data[data_sel], data_sel); 
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'a':*/
/*--------------------------------------------------------------------------*/
on key 'a'
{
  data[data_sel]-=1;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'d':*/
/*--------------------------------------------------------------------------*/
on key 'd'
{
  int s, data_nr; 

  write("%s",leerzeile);
  write("%s",header);
  write("%s",leerzeile);

  /* selektierte Daten ausgeben */
  FOR (s=0; s < spalten_max; s++)
  { 
    data_nr = data_tab[s][zeile_sel[s]];

    /* wenn Zeile aktiv, dann Datum ausgeben */
    if ((data_nr != Unused_Nr) && (data_nr != Reserved_Nr))
    {
      write("Menue: %ld", s);
    
      if (s != spalte_sel)
      { /* Spalte nicht selektiert */ 
        write("> value %s = %d", data_name[data_nr], data[data_nr]);
      }
      else
      { /* Spalte selektiert, d.h. Datum kann aktuell verstellt werden */
        write("* value %s = %d", data_name[data_nr], data[data_nr]);
      }
      write("%s",unterstr);
    }
  }
}
/*@@end*/

/*@@key:'h':*/
/*--------------------------------------------------------------------------*/
on key 'h'
{
  int i;

  write("%s",leerzeile);
  write("%s",header);
  write("Revision %s",revision);
  write("%s",unterstr);
//    write("Key '1'  : Initialise Traminator on CAN 2");
//    write("Key '2'  : Grounding of CANH and CANL");
//    write("Key '3'  : Cancel the grounding of CANH and CANL");
//    write("Key '4'  : Isolation of ECU to test from CAN");
//    write("Key '5'  : Connect ECU to test to CAN");
//    write("Key '6'  : Measurement redundant break propagation delay");
//    write("Key '7'  : Disturbing Dat_CMM EDC-Mute");
//    write("Key '9'  : Cancel script mode and come back to remote mode");

  write("%s",unterstr);

  write("Key 'q','Shift-q','Ctrl-q' : Value = value +1, +10, +100");
  write("Key 'a','Shift-a','Ctrl-a' : Value = value -1, -10, -100");
  write("Key 'W','E'     : Value = value +100,+1000");
  write("Key 'w','e'     : Value = value -100,-1000");
  write("CURSOR <-, ->   : Select menu");
  write("CURSOR UP, DOWN : Select data");
  write("Ctrl-CURSOR UP, DOWN : Select +- 4th data");
  write("Ctrl_F1..F12    : Direct access to menu 1..12");
  write("Key 'd'         : List selected data");
  write("Key 'D'         : List all data");
  write("Key 'm'         : De/activation of frame monitoring"); 
  write("Key 'p'         : Stop period time measurment");
  write("Key 'P'         : Start period time measurment");
  write("Key 'r'         : Reset CAN");
  write("Key 's'         : Stop transmission");

  write("Key 'n'         : Cruise control switch off");
  write("Key 'u'         : Cruise control increment or acceleration");
  write("Key 'i'         : Cruise control decrement or deceleration");

  write("Key 't'         : Send Elec_Int frames");
  write("%s",leerzeile);

  /* Daten, die verstellt werden können */
  FOR (i=0; i < spalten_max; i++)
  { 
    /* wenn Spalte inaktiv */
    if ((data_tab[i][0] == Unused_Nr) || (data_tab[i][0] == Reserved_Nr))
    {
      write("Menue: %ld not used !", i);
    }
    else
    {
      write("Menue: %ld available", i);
    }
  }
  write("%s",header);
}
/*@@end*/

/*@@key:'q':*/
/*--------------------------------------------------------------------------*/
on key 'q'
{
  data[data_sel]+=1;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'r':*/
/*--------------------------------------------------------------------------*/
on key 'r'
{
    //resetCan();
}
/*@@end*/

/*@@key:'s':*/
/*--------------------------------------------------------------------------*/
on key 's'
{
  write("%s",leerzeile);
  write("%s",header);
  write("%s",leerzeile);

  if (sendestopp == 1)
  {
    write("CAN 1 is again active.");
    sendestopp = 0;
  }
  else 
  {
    if (data[Absent_Timer_Nr] == 0x00)
    {
      write("Stop transmission on CAN 1 permanently.");
    }
    else
    {
      setTimer(Absent_Timer, data[Absent_Timer_Nr]);
      write("Stop transmission on CAN 1 for %ld ms.", data[Absent_Timer_Nr]);
    }      
    sendestopp = 1;
  }
}
/*@@end*/

/*@@key:'w':*/
/*--------------------------------------------------------------------------*/
on key 'w'
{
  data[data_sel]-=100;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:'e':*/
/*--------------------------------------------------------------------------*/
on key 'e'
{
  data[data_sel]-=1000;
  data[data_sel] = begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);
}
/*@@end*/

/*@@key:ctrlCursorUp:*/
/*--------------------------------------------------------------------------*/
on key _CurCtrlUp
{
  menue(Ctrl_Up);
}
/*@@end*/

/*@@key:ctrlCursorDown:*/
/*--------------------------------------------------------------------------*/
on key _CurCtrlDown
{
  menue(Ctrl_Down);
}
/*@@end*/

/*@@key:CursorUp:*/
/*--------------------------------------------------------------------------*/
on key _CursorUp
{
  menue(Up);
}
/*@@end*/

/*@@key:CursorLeft:*/
/*--------------------------------------------------------------------------*/
on key _CursorLeft
{
  menue(Left);
}
/*@@end*/

/*@@key:CursorRight:*/
/*--------------------------------------------------------------------------*/
on key _CursorRight
{
  menue(Right);
}
/*@@end*/

/*@@key:CursorDown:*/
/*--------------------------------------------------------------------------*/
on key _CursorDown
{
  menue(Down);
}
/*@@end*/

/*@@key:'t':*/
/*--------------------------------------------------------------------------*/
on key 't'
{
  /* activate sending Elec_Int frames */
  ElecInt_Active = 1;     
  write("Elec_Int sent %ld times with value %ld", ElecInt_NrFrames, data[P__Elec_Int_Cntrl_Word_Nr]);
}
/*@@end*/

/*@@key:'m':*/
/*--------------------------------------------------------------------------*/
on key 'm'
{
  FrameMonActv = ! FrameMonActv;
  if (FrameMonActv)
  {
    write ("Frame monitoring activated\n");
  }
  else
  {
    write ("Frame monitoring deactivated\n");
  }
}
/*@@end*/

/*@@errorFrameErrorFrame:ErrorFrame:*/
/*--------------------------------------------------------------------------*/
on errorFrame 
{
    /* resetCan(); */
}
/*@@end*/

/*@@caplFunc:begrenze(long,byte):*/
/*--------------------------------------------------------------------------*/
long begrenze (LONG data, BYTE data_sel)
{
  /* Werte begrenzen */
  if (data > max_wert[data_sel])
  {
    write("Limitation to maximum !");
    data = max_wert[data_sel];
  }
  else if (data < min_wert[data_sel])
  {
     write("Limitation to minimum !");
     data = min_wert[data_sel];
  }
  return(data);
}
/*@@end*/

/*@@caplFunc:menue(word):*/
/*--------------------------------------------------------------------------*/
void menue (WORD richtung)
{
  BYTE target_spalte;
  if (richtung > Right)
  {
    if (richtung == _Ctrl_F12)
    { target_spalte = 12;
    }
    else if (richtung == _Ctrl_F11)
    { target_spalte = 11;
    }
    else
    {
      target_spalte = ((richtung - _Ctrl_F1) / 0x100) + 1;    /*Exp: ((5F00 - 5E00) / 0x100) + 1 */
    }
    spalte_sel = target_spalte; 
    //write("spalte_sel %X", spalte_sel);
  }
  else
  {

  switch (richtung)
  {
    case Ctrl_Up:
    {
      zeile_sel[spalte_sel] -= 4;
      /* wenn oberste Menuezeile */
      if (zeile_sel[spalte_sel] <= 0)
      {
        /* auf oberste Zeile schalten */
        zeile_sel[spalte_sel] = 0;  
      }
    }
    break;
    case Ctrl_Down:
    {
      zeile_sel[spalte_sel] += 4;
      /* wenn unterste Menuezeile */
      if (zeile_sel[spalte_sel] >= letzte_zeile[spalte_sel])
      {
      /* auf unterste aktive Zeile schalten */
      zeile_sel[spalte_sel] = letzte_zeile[spalte_sel];  
      }
    }
    break;
    case Up:
    {
      /* wenn oberste Menuezeile */
      if (zeile_sel[spalte_sel] == 0)
      {
        /* auf unterste aktive Zeile schalten */
        zeile_sel[spalte_sel] = letzte_zeile[spalte_sel];  
      }
      else
      {
        zeile_sel[spalte_sel]--;
      }
    }
    break;
    case Down:
    {
      /* wenn unterste Menuezeile */
      if (zeile_sel[spalte_sel] == letzte_zeile[spalte_sel])
      {
        /* auf oberste Zeile schalten */
        zeile_sel[spalte_sel] = 0;  
      }
      else
      {
        zeile_sel[spalte_sel]++;
      }
    }
    break;
    case Left:
    {
      /* wenn erstes Menue */
     if (spalte_sel == 0)
      {
        spalte_sel = spalten_max - 1; 
      }
      else
      {
        spalte_sel --;
      }
    }
    break;
    case Right:
    {
      /* wenn letztes Menue */
      if (spalte_sel == spalten_max - 1)
      {
        spalte_sel = 0; 
      }
      else
      {
        spalte_sel ++;
      }
    }
  }
  }
  /* Datum selektieren */
  data_sel = data_tab[spalte_sel][zeile_sel[spalte_sel]];

  /* Daten der Spalte mit Namen und Rohwert sowie selektiertes Datum ausgeben */
  write("%s",header);
  write("Menue %ld: %s", spalte_sel, menu_desc[spalte_sel]);
  write("%s",unterstr);
  print_spalte(spalte_sel);
  write("%s",header);
}
/*@@end*/

/*@@caplFunc:print_spalte(byte):*/
/*--------------------------------------------------------------------------*/
void print_spalte (byte spalte)
{
  int i, z;
  for (z=0; z <= letzte_zeile[spalte]; z++)
  {
    i = data_tab[spalte][z];

    if (z != zeile_sel[spalte])
    { 
      /* Zeile nicht selektiert */ 
      write("  value %s = %d", data_name[i], data[i]);
    }
    else
    { 
      /* Zeile selektiert */
      if (spalte != spalte_sel)
      { /* Spalte nicht selektiert */ 
        write("> value %s = %d", data_name[i], data[i]);
      }
      else
      { 
        /* Spalte selektiert, d.h. Datum kann aktuell verstellt werden */
        write("* value %s = %d", data_name[i], data[i]);
      }
    }
  }
}
/*@@end*/

/*@@caplFunc:versende(message*,byte):*/
/*--------------------------------------------------------------------------*/
void versende (message * msg, byte msg_nr)
{
  if (sendestopp == 0)
  {
    output(msg);
    lost_msg_cnt[msg_nr] = 0;                                   /* Aussetzzaehler zuruecksetzen */
  }
  else
  {
    lost_msg_cnt[msg_nr]++;                                     /* Aussetzzaehler erhoehen */
    /* wenn Option gewaehlt, gebe Aussetzzaehler aus */
    if (data[Absent_Info_Nr] == 1)
    {
      write("Message %s not transmitted for %u times.", tx_msg_name[msg_nr], 
      lost_msg_cnt[msg_nr]);
    }
  }
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::BSI_FaultLog (0x768):*/
on message BSI_FaultLog
{   
    if(BSI_stkeypress)
    {
      FaultLog_Ack.P__FaultLog_Ack = 0x00;

      output(FaultLog_Ack); 
 
    }
  else
  {
    FaultLog_Ack.P__FaultLog_Ack = 0x08;

      output(FaultLog_Ack); 

  }
}
/*@@end*/

/*@@key:*:*/
on key *
{
  if(this == HOME)
  {
     BSI_stkeypress = 1 ; 
   write("(Home ) "); 
  }
  else
  {
      BSI_stkeypress = 0 ;                  

//     write("Taste: %X", this);
  }
  if((this >= _Ctrl_F1 && this <= _Ctrl_F10) || this == _Ctrl_F11 || this == _Ctrl_F12)
  {
    menue(this);  
  }
}
/*@@end*/

/*@@timer:BSI_Ack:*/
on timer BSI_Ack
{
    /* Send the acknowledgement */
   /* FaultLog_Ack.FaultLog_Ack.DLC = 1; */
    FaultLog_Ack.P__FaultLog_Ack = 0x08 ;

  output(FaultLog_Ack); 

  setTimer(BSI_Ack,50);

  FaultLog_Ack.P__FaultLog_Ack = 0x00;

  output(FaultLog_Ack); 

}
/*@@end*/

/*@@timer:timer60ms:*/
on timer timer60ms
{
  setTimer(timer60ms,60);

  Dat_V2_BV.P218_Com_stDrvIdx          = data[P218_Nr]; /* Driving type/ Sportive index  */
  Dat_V2_BV.P282_Com_stGbxErr          = data[P282_Nr]; /* Mil On request status from BVMP  */
  Dat_V2_BV.P285_Com_bPNDia            = data[P285_Nr]; /* Start Inhibition request from BVMP  */
  Dat_V2_BV.P029_Com_stPrg             = data[P029_Nr]; /* Gearbox program */
  Dat_V2_BV.P374_Com_bOBDRdy           = data[P374_Nr]; /* Readiness flag not set for OBD errors on Gbx */
  Dat_V2_BV.P375_Com_bMILDem           = data[P375_Nr]; /* MIL request */
  Dat_V2_BV.P376_Com_bMILcntResDemRaw  = data[P376_Nr]; /* Clear MIL KM counter */  
 /* send message */
  versende(Dat_V2_BV, Dat_V2_BV_Nr);
}
/*@@end*/

/*@@msg:CAN1.CanDB_AEE2010_H91_v1p1_pf::Dyn5_CMM (0x228):*/
on message CAN1.Dyn5_CMM
{
  long sum;
  byte i;

  /* Check of consistency message received and selected PARAMETERS of array */
  if (this.DLC != PARAMETERS[RX_Dyn5_CMM][MON_DLC])
  {
    MON_ErrorMessage(RX_Dyn5_CMM, 2);
  }

  /* Calculate the checksum of the frame 0x228 */
  sum = 0;
  for ( i =0; i< PARAMETERS[RX_Dyn5_CMM][MON_DLC] ; i++)
  {
    sum = sum + (this.byte(i) & 0x0F);
  sum = sum & 0x0F;
  sum = sum + ( (this.byte(i) & 0xF0) >> 0x04 );
  sum = sum & 0x0F;
  }

  sum = sum + 0x0C ;
  sum = sum & 0x0F ;

  if(sum != 0x0F)
  {
     write ("Checksum of 0x228 in not ok\n It is %X", sum);
  }
}
/*@@end*/

/*@@timer:timer_dynbva:*/
on timer timer_dynbva
{

  if (data[BVMPAactive_Nr])
  {
    /* Erzeuge Message Dyn_V2_BVMP 349 */
    
    //DYN_V2_BVMP.P087_Com_stClth                = data[P087_Nr];     /* Clutch state */
    DYN_V2_BVMP.P009_Com_bGearShftActv         = data[P009_Nr];     /* shifting in progress FrmMng_stGearShift */
    DYN_V2_BVMP.P085_Com_bGbxACCmprShOff       = data[P085_Nr];     /* AC compressor inhibit FrmMng_stReqFrzACC  */
    DYN_V2_BVMP.P167_Com_stEngSpdCtl           = data[P167_Nr];     /* state of engine speed control  */
    DYN_V2_BVMP.P287_Com_stGearRat             = data[P287_Nr];     /* Gear engaged */
    DYN_V2_BVMP.P283_Com_stGearTrgtPos         = data[P283_Nr];     /* target gear */
    //DYN_V2_BVMP.P055_Com_trqTSCAbs             = data[P055_Nr];     /* Torque limitation for gear box / Absolute torque request  */
    DYN_V2_BVMP.P166_Com_nEngTSC               = data[P166_Nr];     /* Desired engine speed  */
    DYN_V2_BVMP.P030_Gbx_stDrvTrnEgd           = data[P030_Nr];     /* Desired engine speed  */
    DYN_V2_BVMP.P360_Com_stIntvTyp             = data[P360_Nr];     /* gearbox intv type  */
    //DYN_V2_BVMP.P361_Com_stTscEngDemTyp        = data[P361_Nr];     /* engine speed intv  */
    DYN_V2_BVMP.P333_Com_stGbxTrqIntv          = data[P333_Nr];     /* gearshift phase */
    DYN_V2_BVMP.P362_Com_bGearShftExpt         = data[P362_Nr];     /* gearshift progress  */
    DYN_V2_BVMP.P057_Com_xTrqTIIDes            = data[P057_Nr];     /* TII intervention  */
    DYN_V2_BVMP.P440_Com_bUCAPSWkUpReqRaw      = data[P440_Nr];     /* */
    
    /* calculate frame counter P230 for DYN_V2_BVMP 349: */
    if (data[Sim_counter_hang_349_Nr] == 0)              /* BVMP simulation of counter is hanging */
    {
      proc_counter_349 = (proc_counter_349 + 1) & 0x0F; 
    }
    else
    {
      proc_counter_349 = (proc_counter_349 + ((data[Sim_counter_hang_349_Nr] -1) & 0x0f)) & 0x0F; 
    }  

    DYN_V2_BVMP.P230_Com_ctTSCCntr      = proc_counter_349;     /* Process counter */

    /* calculate checksum P340 for DYN_V2_BVMP 349: */
    /* Init local variables */
    ChkSum_349 = 0;
    ChkSum_349_Tmp = 0;
   
    /* Checksum is calculated so that the Mod16 addition of all the nibbles of the frame including
       the checksum is 0x0F */

    if (data[Sim_chksum_fault_349_Nr] == 0)                         /* ChkSum not faulty */
    {
      /* Add P030 & lower part of P360 */
      ChkSum_349 = ( data[P030_Nr] + ( (data[P360_Nr] << 0x02) & 0x0F)) ;
      /* higher part of P360 & P440 */
      ChkSum_349_Tmp = (((data[P360_Nr] << 0x02) & 0xF0) >> 0x04) + (data[P440_Nr] << 1);
      ChkSum_349 = ChkSum_349 + ChkSum_349_Tmp;
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P057 */
      ChkSum_349 = ChkSum_349 + ( data[P057_Nr] & 0x0F);
      ChkSum_349 = (ChkSum_349 & 0x0F);
      ChkSum_349 = ChkSum_349 + ( (data[P057_Nr] & 0xF0) >> 0x04);
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P009 + P362 + P333 */
      ChkSum_349_Tmp =  data[P009_Nr] + (data[P362_Nr] << 0x01) + (data[P333_Nr] << 0x02);
      ChkSum_349 = ChkSum_349 + ChkSum_349_Tmp;
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P085 + P1671 */
      ChkSum_349_Tmp =  (data[P085_Nr]) + (data[P167_Nr] << 0x01);
      ChkSum_349 = ChkSum_349 + ChkSum_349_Tmp;
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P283 */
      ChkSum_349 = ChkSum_349 + data[P283_Nr];
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P287 */
      ChkSum_349 = ChkSum_349 + data[P287_Nr];
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P230 */
      ChkSum_349 = ChkSum_349 + (proc_counter_349 & 0x0F);
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* P166 */
      ChkSum_349 = ChkSum_349 + ( data[P166_Nr] & 0x0F);
      ChkSum_349 = (ChkSum_349 & 0x0F);
      ChkSum_349 = ChkSum_349 + ( (data[P166_Nr] & 0xF0) >> 0x04);
      ChkSum_349 = (ChkSum_349 & 0x0F);
      /* Checksum INI : 0x09 */
      ChkSum_349 = ChkSum_349 + 0x09 ;       /* ini for Dyn_V2_BVMP = 09h */
      ChkSum_349 = (ChkSum_349 & 0x0F);

      ChkSum_349 = (0x0F - ChkSum_349);

    }
    DYN_V2_BVMP.P340_Com_xTSCChkSum    = ChkSum_349 ;         /* Checksum from BVMP */

    /* versende Messages */
    versende(DYN_V2_BVMP, Dyn_V2_BVMP_Nr);

  } // If BVMP active

  if(Timer_DynBVA_Flag == 1)
  {
    switch(Timer_DynBVA_Var)
    { 
      case (1) :
        setTimer(timer_dynbva,0, 9750*1000);
        Timer_DynBVA_Var = 2;
      break;
      case (2) :
        setTimer(timer_dynbva,0, 10250*1000);
        Timer_DynBVA_Var = 3;
      break;
      case (3) :
        setTimer(timer_dynbva,0, 10000*1000);
        Timer_DynBVA_Var = 4;
      break;
      case (4) :
        setTimer(timer_dynbva,0, 10250*1000);
        Timer_DynBVA_Var = 5;
      break;
      case (5) :
        setTimer(timer_dynbva,0, 9750*1000);
        Timer_DynBVA_Var = 1;
      break;
      default :
        setTimer(timer_dynbva,0, 10000*1000);
        Timer_DynBVA_Var = 1;
      break;
    }
  }
  else
  {
      setTimer(timer_dynbva,0, 10000*1000);
  }

}
/*@@end*/

/*@@key:'z':*/
on key 'z'
{
     Timer_DynBVA_Flag = 1 ; 
   write("BVA now with disturbances ) "); 
}
/*@@end*/

/*@@key:'Z':*/
on key 'Z'
{
     Timer_DynBVA_Flag = 0 ; 
   write("(BVA with normal duration) "); 
}
/*@@end*/

/*@@caplFunc:send(long,long):*/
void send (LONG data_sel, LONG data_value)
{
 
  /* write("value %ld", Varname); 
  write("value %s = %ld", buffer, data_value);
  write("value P214_Com_stMnWkUp = %ld", Value);*/
  data[data_sel] =  data_value;
  data[data_sel] =  begrenze (data[data_sel], data_sel);
  write("value %s = %ld", data_name[data_sel], data[data_sel]);


}
/*@@end*/

